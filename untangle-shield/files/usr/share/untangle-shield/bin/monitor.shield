#!/bin/dash

mkdir -p /var/log/untangle-shield
exec >> /var/log/untangle-shield/monitor.log 2>&1

NAME="shield"

load_defaults()
{
    SHIELD_BIND_PORT="3001"
    SHIELD_QUEUE_NUM="3001"
    
    SHIELD_CONF_FILE="/etc/untangle-shield.conf"
    SHIELD_USER_FILE="/var/run/shield-users.conf"
    
    SHIELD_LOG_OUT="/var/log/untangle-shield/debug.log"
    SHIELD_LOG_ERR="/var/log/untangle-shield/error.log"
    
    SHIELD_IPTABLES_INSERT_CMD="/etc/init.d/untangle-net-alpaca-iptables restart"
    SHIELD_IPTABLES_REMOVE_CMD="/etc/init.d/untangle-net-alpaca-iptables restart"

    if [ -f /etc/default/untangle-shield ] ; then
        . /etc/default/untangle-shield
    fi
}

remove_iptables()
{
    if [ ! -z "$SHIELD_IPTABLES_REMOVE_CMD" ] ; then
        $SHIELD_IPTABLES_REMOVE_CMD
    fi
}

insert_iptables()
{
    if [ ! -z "$SHIELD_IPTABLES_INSERT_CMD" ] ; then
        $SHIELD_IPTABLES_INSERT_CMD
    fi
}

reap_child_hardest()
{
  reap_child 9
}

reap_child_harder()
{
    trap reap_child_hardest INT TERM USR1 USR2 QUIT
    reap_child 15
}

reap_child_easy()
{
    trap reap_child_harder INT TERM USR1 USR2 QUIT
    reap_child 2
}

reap_child()
{
    echo "[`date`] Received Signal      (monitor: $$) (shield: $SHIELD_PID) (sending signal: $1) "

    if [ ! -z "$SHIELD_PID" ] ; then
        echo "[`date`] Sending signal $1 to Shield ($SHIELD_PID)."
        kill -$1 ${SHIELD_PID}
        wait $SHIELD_PID
        echo "[`date`] Shield Stopped       (monitor: $$) (shield: $SHIELD_PID)"
        remove_iptables
    fi

    exit 0
}

start_shield()
{
    load_defaults
    
    local t_args="${SHIELD_ARGS}"
    local t
    
    test -n "${SHIELD_BIND_PORT}" && t_args="${t_args} -p ${SHIELD_BIND_PORT}"
    test -n "${SHIELD_QUEUE_NUM}" && t_args="${t_args} -q ${SHIELD_QUEUE_NUM}"
    test -n "${SHIELD_CONF_FILE}" && t_args="${t_args} -c ${SHIELD_CONF_FILE}"
    test -n "${SHIELD_USER_FILE}" && t_args="${t_args} -b ${SHIELD_USER_FILE}"
    test -n "${SHIELD_LOG_OUT}" && t_args="${t_args} -o ${SHIELD_LOG_OUT}"
    test -n "${SHIELD_LOG_ERR}" && t_args="${t_args} -e ${SHIELD_LOG_ERR}"
    
    /usr/bin/${NAME} ${t_args} &
    SHIELD_PID=$!

    ## Give it some time to grab the queue so iptables knows that it is still running
    for t in '1 2 3 4 5 6 7 8 9 10'; do
        sleep 1
        is_running && break
    done
    insert_iptables
}

is_running()
{
    ## First just validate that the queue is bound
    if [ ! -f /proc/net/netfilter/nfnetlink_queue ] ; then return 1 ; fi

    local t_queue_pid=`awk -v queue=${SHIELD_QUEUE_NUM} '{ if ( $1 == queue ) print $2 }' /proc/net/netfilter/nfnetlink_queue`
    if [ -z "${t_queue_pid}" ]; then return 1 ; fi

    ## Perform a simple curl call to make sure the server is running.
    curl -sf -F 'json_request=@-' -m 10 "http://localhost:${SHIELD_BIND_PORT}"  > /dev/null 2>&1 <<EOF
{ "function" : "hello_world" }
EOF
}

trap reap_child_easy INT TERM USR1 USR2 QUIT

while ( true ) ;  do
    echo "[`date`] Starting Shield"

    start_shield
    sleep 2
    echo "[`date`] Monitoring Shield   (monitor: $$) (shield: $SHIELD_PID)"
    wait $SHIELD_PID

    echo "[`date`] Shield Died!        (monitor: $$) (shield: $SHIELD_PID)"
done
