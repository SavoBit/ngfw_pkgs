#! /bin/dash

### BEGIN INIT INFO
# Provides:          untangle-net-alpaca-iptables
# Required-Start:    $local_fs $network $syslog
# Required-Stop:     $local_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Untangle Network Alpaca (iptables)
### END INIT INFO

# Author: Robert Scott <rbscott@untangle.com>

. /lib/lsb/init-functions

DESC="Untangle Net-Alpaca iptables rules"

IPTABLES_RULES=/etc/untangle-net-alpaca/scripts/iptables
HELPER_MODULES=/usr/share/untangle-net-alpaca/scripts/load-modules

## This should be a file containing all of the iptables tables
IPTABLES_NAMES=/proc/net/ip_tables_names

# Lock file
LOCK_FILE=/tmp/untangle-net-alpaca-iptables.lock

insert_rules()
{
    ## Force untangle-net-alpaca to write network configuration file
    # Ideally untangle-net-alpaca would do this automatically on startup
    # short of that I've inserted it here
    curl -s -o /dev/null http://127.0.0.1:3000/alpaca/uvm/write_files?argyle=`head -n1 /etc/untangle-net-alpaca/nonce`

    # make sure privileges don't persist across reboots
    if [ -f ${IPTABLES_RULES} ]; then
        sh ${IPTABLES_RULES}
    else
        /bin/echo "The file '${IPTABLES_RULES}' does not exist"
    fi
    if [ -x ${HELPER_MODULES} ]; then
        ${HELPER_MODULES}
    else
        /bin/echo "The file '${HELPER_MODULES}' does not exist"
    fi
}

remove_rules()
{
    local t_table

    if [ -f ${IPTABLES_NAMES} ]; then
        for t_table in `cat ${IPTABLES_NAMES}` ; do 
            /sbin/iptables -t ${t_table} -F || true
        done        
    else
        /bin/echo "The file '${IPTABLES_NAMES}' does not exist, unable to flush the iptables rules"
    fi

    ## Flushing the ebtables rules.
    if [ -x /sbin/ebtables ]; then
        for t_table in filter nat broute ; do 
            /sbin/ebtables -t ${t_table} --init-table || true
        done
    fi
}

run_function_lock()
{
    local t_function
    local t_count

    t_function=$1
    t_count=0

    while true ; do
        if ( set -o noclobber; echo "$$" > "$LOCK_FILE" ) 2> /dev/null; then
            trap 'rm -f "$LOCK_FILE"; exit $?' INT TERM EXIT
            
            # critical section
            ${t_function}
            
            rm -f "$LOCK_FILE"
            trap - INT TERM EXIT
            log_end_msg 0
            break
        else
            log_progress_msg "."
            sleep .2
            
            # timeout
            t_count=$(($t_count+1))
            if [ $t_count -gt 100 ] ; then 
                rm -f "$LOCK_FILE" 
                log_progress_msg "Removing stale lock"
                log_progress_msg "Forcing function to run"
                ${t_function}
                break
            fi
        fi 
    done
}

case "$1" in
    ## start script includes stop/flush
    start|reload|restart|force-reload)
        log_daemon_msg "Loading $DESC"
        run_function_lock insert_rules
        ;;

    stop)
        log_daemon_msg "Removing $DESC"

        run_function_lock remove_rules
        ;;        

    *)
        /bin/echo "Usage: $0 {start|stop|restart|force-reload}" >&2
        exit 1
        ;;
esac

exit 0

