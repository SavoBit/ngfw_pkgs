#!/bin/bash 
#The Wonder Shaper        1.1a
#bert hubert <ahu@ds9a.nl>
#http://lartc.org/wondershaper
#(c) Copyright 2002 
#Licenced under the GPL - see 'COPYING'
#
# Modified by Untangle, Inc. 2008
# Copyright (c) 2008 Untangle, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
# NONINFRINGEMENT.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.


#set these in /etc/untangle-net-alpaca/untangle-qos which is handled by the alpaca UI
DOWNLINK=
UPLINK=
DEV=

if [ -e /etc/untangle-net-alpaca/untangle-qos ] ; then
   . /etc/untangle-net-alpaca/untangle-qos
else
   exit 2
fi

dump_status()
{
    local t_dev

    for t_dev in $UPLINKS ; do
        echo "Statistics for link ${t_dev}"
        tc -s qdisc ls dev $t_dev 
        tc -s class ls dev $t_dev 
    done
}

dump_alpaca_status()
{
    local t_dev

    for t_dev in $UPLINKS ; do
        tc -s class ls dev $t_dev | sed "/^class/iinterface: ${t_dev}"
    done
}

flush_rules()
{
    local t_dev

    for t_dev in $UPLINKS ; do
        # clean existing down- and uplink qdiscs, hide errors
        tc qdisc del dev $t_dev root    2> /dev/null > /dev/null
        tc qdisc del dev $t_dev ingress 2> /dev/null > /dev/null
    done
    
    
    #make sure we clean everything by iterating over the lists of devices
    # that have a queueing discipline
    #but utun has rules on it without QoS so leave those alone
    for t_dev in `tc qdisc show | awk '{ print $5; }' ` ; do
        if [ "$t_dev" != "utun" ] ;  then
            tc qdisc del dev "$t_dev" root    2> /dev/null > /dev/null
            tc qdisc del dev "$t_dev" ingress 2> /dev/null > /dev/null
        fi
    done
}

pre_tc_rules()
{
    local t_dev
    local t_upload

    local t_pppoe_dev

    t_dev=$1
    t_upload=`eval echo "\\$${t_dev}_UPLOAD"`

    if [ -z "${t_dev}" ] || [ -z "${t_upload}" ]; then
        echo "The upload speed is not specified for '${t_dev}'"
        return
    fi
    
    t_pppoe_dev=`eval echo "\\$PPPOE_INTERFACE_${t_dev}"`
    
    if [ -n "${t_pppoe_dev}" ]; then
        t_dev=${t_pppoe_dev}
    fi
    
    ###### uplink
    # install root HTB, point default traffic to 1:20:
    tc qdisc add dev $t_dev root handle 1: htb default 20

    # shape everything at $t_upload speed - this prevents huge queues in your
    # DSL modem which destroy latency:
    tc class add dev $t_dev parent 1: classid 1:1 htb rate ${t_upload}kbit burst 18k

    # high prio class 1:10:
    tc class add dev $t_dev parent 1:1 classid 1:10 htb rate ${t_upload}kbit \
        burst 16k prio 1

    # bulk & default class 1:20 - gets slightly less traffic, 
    # and a lower priority:
    tc class add dev $t_dev parent 1:1 classid 1:20 htb rate $[9*$t_upload/10]kbit \
        burst 8k prio 2

    tc class add dev $t_dev parent 1:1 classid 1:30 htb rate $[8*$t_upload/10]kbit \
        burst 6k prio 3

    # all get Stochastic Fairness:
    tc qdisc add dev $t_dev parent 1:10 handle 10: sfq perturb 10
    tc qdisc add dev $t_dev parent 1:20 handle 20: sfq perturb 10
    tc qdisc add dev $t_dev parent 1:30 handle 30: sfq perturb 10

    tc filter add dev $t_dev protocol ip parent 1: prio 1 u32 match mark 0x0c00000 0x0e00000 flowid 1:10
    tc filter add dev $t_dev protocol ip parent 1: prio 2 u32 match mark 0x0400000 0x0e00000 flowid 1:20
    tc filter add dev $t_dev protocol ip parent 1: prio 3 u32 match mark 0x0200000 0x0e00000 flowid 1:30
}

post_tc_rules()
{
    local t_dev
    local t_download

    t_dev=$1
    t_download=`eval echo "\\$${t_dev}_DOWNLOAD"`

    if [ -z "${t_dev}" ] || [ -z "${t_download}" ]; then
        echo "The download is not specified for '${t_dev}'"
        return
    fi

    t_pppoe_dev=`eval echo "\\$PPPOE_INTERFACE_${t_dev}"`
    
    if [ -n "${t_pppoe_dev}" ]; then
        t_dev=${t_pppoe_dev}
    fi

    # rest ends up in 1:20
    #tc filter add dev $t_dev parent 1: protocol ip prio 20 u32 \
    #   match ip dst 0.0.0.0/0 flowid 1:20

    ########## download #############
    # slow downloads down to somewhat less than the real speed  to prevent 
    # queuing at our ISP. Tune to see how high you can set it.
    # ISPs tend to have *huge* queues to make sure big downloads are fast
    #
    # attach ingress policer:
    tc qdisc add dev $t_dev handle ffff: ingress
    
    # filter *everything* to it (0.0.0.0/0), drop everything that's
    # coming in too fast:
    #only drop TCP
    tc filter add dev $t_dev parent ffff: protocol ip prio 50 u32 match ip protocol 6 0xff match ip \
        src 0.0.0.0/0 police rate $[95*${t_download}/100]kbit burst 300kb drop flowid :1
    
    #limit ping to 25% of total bandwidth
    tc filter add dev $t_dev parent ffff: protocol ip prio 50 u32 match ip protocol 1 0xff match ip \
        src 0.0.0.0/0 police rate $[25*${t_download}/100]kbit burst 30kb drop flowid :1
}

## Start of script
if [ "${1}x" = "statusx" ]; then
    dump_status
    exit 0
fi

## Start of script
if [ "${1}x" = "alpaca_statusx" ]; then
    dump_alpaca_status
    exit 0
fi


flush_rules

if [ "${1}x" = "stopx" ]; then 
    exit
fi

if [ "${1}x" != "startx" ]; then
    exit
fi

if [ "${QOS_ENABLED}x" != "YESx" ]; then
    exit
fi

touch /var/log/untangle-net-alpaca/qosstart.log

for uplink in ${UPLINKS}; do
    pre_tc_rules ${uplink}
done

run-parts /etc/untangle-net-alpaca/tc-rules.d

for uplink in ${UPLINKS}; do
    post_tc_rules ${uplink}
done




