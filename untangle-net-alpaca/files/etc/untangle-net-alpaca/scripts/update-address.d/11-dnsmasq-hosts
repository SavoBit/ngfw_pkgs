#!/bin/dash

## Add entries for the hostname
current_hostname=`hostname`

MARKER="hostname.marker.untangle.com"
OLD_MARKER="ut-marker.example.com"

## This gets all addresses.
get_addresses()
{
    ip addr show | awk '/^[0-9]/ { current_intf=$2 } ; /inet/ { ip = $2 ; sub( /\/.*$/, "", ip ) ; if ( current_intf != "dummy0:" && current_intf != "utun:" && current_intf != "lo:" ) print ip  }'
}

## Grab the domain name
get_domain_name()
{
    local t_domain_name
    t_domain_name=`awk '/^\s*search/ { print $2 ; exit }' /etc/resolv.conf`
    [ -n "${t_domain_name}" ] && {
        echo ${t_domain_name}
        return
    }

    ## Otherwise, try to get it out of /etc/dnsmasq.conf
    awk '/domain=/ { sub( "domain=", "" ); print $0; exit }; /domain-suffix=/ { sub( "domain-suffix=", "" ); print $0; exit }' '/etc/dnsmasq.conf'
}


pppoe_interface()
{
    test -f /etc/network/interfaces || return
    
    ## Grab the provider.
    local t_provider=`awk '/ppp0/ { is_ppp = true }; /^[\t ]*provider/ { sub( /^[\t ]*provider[\t ]*/, "" ) ; if ( is_ppp == true ) print }' /etc/network/interfaces`

    ## check if there is actually a provider
    test -z "${t_provider}" && return
    
    ## Now grab the interface that is linked to this provider.
    t_provider="/etc/ppp/peers/${t_provider}"
    test -f ${t_provider} || return

    ## Now print out the name of the interface that is used
    awk '/^[ \t]*plugin rp-pppoe.so/ { sub( /[ \t]*plugin rp-pppoe.so[ \t]*/, "" ); print }' ${t_provider}
}



## This gets just the address that is used to contact the default
## route.  This is probably the address the user is interested in.
## Creating an IP with all of the addresses has a few side effects
## with sessions that are redirected back inside.  Overriding the
## previous function so it is available if we ever want to use
## the new behavior.
get_addresses()
{
    local t_interface="`pppoe_interface`"
    local t_address
    
    ## Always favor aliases assigned to the PPPoE interface.
    test -n "${t_interface}" && {
        t_address=`ip addr show ${t_interface} | awk "/^ *inet.*scope global ${t_interface}/ { interface = \\$2 ; sub( \"/.*\", \"\", interface ) ; print interface ; exit }"`

        ## If there is an address on the PPPoE interface, then go with that.
        test -n "${t_address}" && {
            echo "${t_address}"
            return 0
        }
    }

    ## otherwise use the default route to calculate it.
    ## lookup the interface with the default route
    local t_interface="`ip route show | awk '/^default/ { print $5 }'`"    
    
    ## Find the first address assigned to that interface.
    test -n "${t_interface}" && ip addr show ${t_interface} | awk "/^ *inet.*scope global ${t_interface}/ { interface = \$2 ; sub( \"/.*\", \"\", interface ) ; print interface ; exit }"
}

update_dnsmasq_hosts()
{
    local t_address
    local t_host_script=""
   
    local t_temp=`mktemp`
    local t_dest="/etc/untangle-net-alpaca/dnsmasq-hosts"

    for t_address in `get_addresses` ; do
        t_host_script="${t_host_script} print \"${t_address}  ${current_hostname} ${MARKER}\";"
    done
    
    ## Remove the existing hostname entries and update the new one.
    awk '!'"/(${MARKER}|${OLD_MARKER})/ { print \$0 }; END { ${t_host_script} }" ${t_dest} > ${t_temp}
    chmod 744 ${t_temp}
    mv ${t_temp} ${t_dest}
}

if [ -z "${current_hostname}" ]; then
    echo "[`date`] hostname is not available"
    exit 0
fi

short_name=${current_hostname%%.*}

if [ "${short_name}x" = "${current_hostname}x" ]; then
    ## Hostname is unqualified, append the domain name.
    domain_name=`get_domain_name`
    [ -n "${domain_name}" ] && current_hostname="${current_hostname} ${short_name}.${domain_name}"
else
    ## Hostname is qualified, append the short name as well.
    current_hostname="${short_name} ${current_hostname}"
fi

update_dnsmasq_hosts

currentPid=`pidof dnsmasq`

## Notify dnsmasq of the changes.
test -n "${currentPid}" && kill -HUP ${currentPid}

exit 0
