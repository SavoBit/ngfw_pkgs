#!/bin/bash 
# Licenced under the GPL - see 'COPYING'
#
# Modified by Untangle, Inc. 2010
# Copyright (c) 2008 Untangle, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
# NONINFRINGEMENT.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

# read configuration file
if [ -e /etc/untangle-net-alpaca/qos-config ] ; then
    . /etc/untangle-net-alpaca/qos-config
else
    exit 2
fi

run ()
{
    # echo $1
    /bin/sh -c "$1"
}

imq_dev()
{
    echo $1 | sed 's/eth/imq/'
}
    

flush_htb_rules()
{
    local wan_dev
    local imq_dev

    run "### Flush HTB ###"

    for wan_dev in $(echo $UPLINKS) ; do
        imq_dev=$(imq_dev $wan_dev)
        # clean existing down- and uplink qdiscs, hide errors
        run "tc qdisc del dev $wan_dev root    2> /dev/null > /dev/null"
        run "tc qdisc del dev $wan_dev ingress 2> /dev/null > /dev/null"
        run "tc qdisc del dev $imq_dev root    2> /dev/null > /dev/null"
        run "tc qdisc del dev $imq_dev ingress 2> /dev/null > /dev/null"
    done
    
    #make sure we clean everything by iterating over the lists of devices
    #that have a queueing discipline but utun has rules on it without QoS so leave those alone
    for wan_dev in `tc qdisc show | awk '{ print $5; }' ` ; do
        if [ "$wan_dev" != "utun" ] ;  then
            run "tc qdisc del dev $wan_dev root    2> /dev/null > /dev/null"
            run "tc qdisc del dev $wan_dev ingress 2> /dev/null > /dev/null"
        fi
    done
}


add_htb_rules()
{
    if [ -z $1 ] ; then
        echo "add_rules requires argument"
        exit 1
    fi

    run "### Add HTB ###"

    wan_interface=$1
    imq_interface=$(imq_dev $1)

    add_qdisc="tc qdisc add dev " 
    add_class="tc class add dev " 
    add_filtr="tc filter add dev " 
    SFQ="sfq perturb 10"
    
    #
    # egress filtering
    #
 	run "$add_qdisc $wan_interface root handle 1: htb default 1$DEFAULT_CLASS"
    UPLOAD_BANDWIDTH=$(eval echo "$"${wan_interface}_UPLOAD_BANDWIDTH)
 	run "$add_class $wan_interface parent 1: classid 1:1 htb rate ${UPLOAD_BANDWIDTH}kbit"
    for i in 1 2 3 4 5 6 7 ; do 
        UPLOAD_RESERVED=$(eval echo "$"${wan_interface}_CLASS${i}_UPLOAD_RESERVED)
        UPLOAD_LIMIT=$(eval echo "$"${wan_interface}_CLASS${i}_UPLOAD_LIMIT)

        if [ $UPLOAD_RESERVED = "none" ] && [ $UPLOAD_LIMIT = "none" ] ; then
            # echo - skipping $i
            continue
        fi

        if [ $UPLOAD_RESERVED = "none" ] ; then
            # should never happen as UPLOAD_RESERVED must be 1-100
            # Can't provide no reservation,TC says '"rate" is required'
            RESERVED=" rate 100kbit "
            UPLOAD_RESERVED=100
        else
            RESERVED=" rate ${UPLOAD_RESERVED}kbit "
        fi

        if [ $UPLOAD_LIMIT = "none" ] ; then
            LIMITED=" ceil 99999999999kbit"
        else
            LIMITED=" ceil ${UPLOAD_LIMIT}kbit "
        fi

        QUANTUM=`perl -e "print int((($UPLOAD_RESERVED/$UPLOAD_BANDWIDTH)*60000))"`
        if [ $QUANTUM -lt 2000 ] ; then QUANTUM=2000; fi

        # egress outbound hierarchical token bucket for class $i - need quantum or prio?
 	    run "$add_class $wan_interface parent 1:1 classid 1:1${i} htb $RESERVED $LIMITED quantum $QUANTUM"
        run "$add_qdisc $wan_interface parent 1:1$i handle 1$i: $SFQ"
        run "$add_filtr $wan_interface parent 1: prio 1$i protocol ip u32 match mark 0x0${i}00000 0x0700000 flowid 1:1$i"
    done


    #
    # ingress filtering
    # ingress filtering is done via the IMQ interface
    #
    run "ifconfig $imq_interface up"
 	run "$add_qdisc $imq_interface root handle 1: htb default 1$DEFAULT_CLASS"
    DOWNLOAD_BANDWIDTH=$(eval echo "$"${wan_interface}_DOWNLOAD_BANDWIDTH)
 	run "$add_class $imq_interface parent 1: classid 1:1 htb rate ${DOWNLOAD_BANDWIDTH}kbit"
    for i in 1 2 3 4 5 6 7 ; do 
        DOWNLOAD_RESERVED=$(eval echo "$"${wan_interface}_CLASS${i}_DOWNLOAD_RESERVED)
        DOWNLOAD_LIMIT=$(eval echo "$"${wan_interface}_CLASS${i}_DOWNLOAD_LIMIT)

        if [ $DOWNLOAD_RESERVED = "none" ] && [ $DOWNLOAD_LIMIT = "none" ] ; then
            # echo - skipping $i
            continue
        fi

        if [ $DOWNLOAD_RESERVED = "none" ] ; then
            # should never happen as DOWNLOAD_RESERVED must be 1-100
            # Can't provide no reservation,TC says '"rate" is required'
            RESERVED=" rate 100kbit "
            DOWNLOAD_RESERVED=100
        else
            RESERVED=" rate ${DOWNLOAD_RESERVED}kbit "
        fi

        if [ $DOWNLOAD_LIMIT = "none" ] ; then
            LIMITED=" ceil 99999999999kbit"
        else
            LIMITED=" ceil ${DOWNLOAD_LIMIT}kbit "
        fi

        QUANTUM=`perl -e "print int((($DOWNLOAD_RESERVED/$DOWNLOAD_BANDWIDTH)*60000))"`
        if [ $QUANTUM -lt 2000 ] ; then QUANTUM=2000; fi

        # ingress inbound hierarchical token bucket for class $i - need quantum or prio?
 	    #run "$add_class $imq_interface parent 1:1 classid 1:1${i} htb $RESERVED $LIMITED quantum $QUANTUM"
 	    run "$add_class $imq_interface parent 1:1 classid 1:1${i} htb $RESERVED $LIMITED"
        run "$add_qdisc $imq_interface parent 1:1$i handle 1$i: $SFQ"
        run "$add_filtr $imq_interface parent 1: prio 1$i protocol ip u32 match mark 0x00${i}00000 0x00700000 flowid 1:1$i"
    done
}

stop()
{
    flush_htb_rules

    exit 0
}

start()
{
    flush_htb_rules

    if [ "${QOS_ENABLED}x" != "YESx" ]; then
        exit
    fi

    run "modprobe imq"

    for i in $(echo $UPLINKS) ; do
        add_htb_rules $i
    done

    exit
}

status()
{
    for wan_dev in $(echo $UPLINKS) ; do
        imq_dev=$(imq_dev $wan_dev)
        tc -s class ls dev $wan_dev | sed "s/\(^class.*\)/interface: ${wan_dev} \1/" 
        tc -s class ls dev $imq_dev | sed "s/\(^class.*\)/interface: ${imq_dev} \1/" 
    done
#    echo "------ Qdisc  ------"
#    tc -s qdisc ls dev $i
#    echo "------ Class  ------"
#    tc -s class ls dev $i
#    echo "------ Filter ------"
#    tc -s filter ls dev $i
}

sessions()
{
    cat /proc/net/ip_conntrack | grep -v '127.0.0.1' | grep tcp | sed 's/[a-z]*=//g' | awk '{printf "proto %s state %s src %s dst %s src-port %s dst-port %s packets %s bytes %s priority %x\n", $1, $4, $5, $6, $7, $8, $9, $10, rshift(and($18,0x00700000),20)}'
    cat /proc/net/ip_conntrack | grep -v '127.0.0.1' | grep udp | sed 's/\[.*\]//g' | sed 's/[a-z]*=//g' | awk '{printf "proto %s state xx src %s dst %s src-port %s dst-port %s packets %s bytes %s priority %x\n", $1, $4, $5, $6, $7, $8, $9, rshift(and($16,0x00700000),20)}'
}

if [ $# -lt 1 ] ; then
    echo "Usage $0 {start|stop|status|sessions}"
    exit 1
fi

case "$1" in
    stop)
        stop
        ;;
    start)
        start
        ;;
    status)
        status
        ;;
    sessions)
        sessions
        ;;
    *)
        echo "unknown argument: ${1}"
        exit 1
esac


exit

