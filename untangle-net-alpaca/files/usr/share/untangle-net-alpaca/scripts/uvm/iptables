#!/bin/dash

## Function to determine the pid of the process that owns the queue

UVM_PID="invalid"

TUN_DEV=utun
TUN_ADDR="192.0.2.43"
MARK_ANTISUB=$((0x01000000))
MARK_NOTRACK=$((0x02000000))
MARK_FIRST_ALIAS=$((0x10000000))
MARK_DUPE=$((0x20000000))
MARK_LOCAL=$((0x0100))
LOCAL_UVM_REDIRECT="uvm-tcp-redirect"

MASK_WAN=${MASK_WAN:-$((0x01))}
MASK_NON_WAN=${MASK_NON_WAN:-$(( ${MASK_WAN} ^ 0xFF ))}

## Always set this just in case.
TCP_REDIRECT_PORTS="9500-9627"
HTTP_INTERNAL_REDIRECT_PORT="64156"
HTTPS_INTERNAL_REDIRECT_PORT="64157"
## This is the port the UVM is serving HTTPs on the external interface.
HTTPS_EXTERNAL_PORT="443"

## This is the address everything in the UVM binds to.
UVM_BIND_ADDRESS="192.0.2.42"

## UDP Session timeout
UDP_SESSION_TIMEOUT=70

uvm_shield_traffic()
{
    SHIELD_QUEUE_NUM=3001

    if [ -f /etc/default/untangle-shield ]; then 
        . /etc/default/untangle-shield
    fi

    local t_queue_pid=`awk -v queue=${SHIELD_QUEUE_NUM} '{ if ( $1 == queue ) print $2 }' /proc/net/netfilter/nfnetlink_queue`

    if [ -z "${t_queue_pid}" ]; then 
        echo "[`date`] Shield is not running, ignoring queue rules."
        return
    fi

    echo "[`date`] Shield is running, inserting queue rules."

    ## Queue any TCP that is not antisubscribed
    ${IPTABLES} -t mangle -I FORWARD 1 -p tcp -m mark --mark 0/${MARK_ANTISUB} \
        -m conntrack --ctstate NEW \
        -j NFQUEUE --queue-num ${SHIELD_QUEUE_NUM}
    
    ${IPTABLES} -t mangle -I FORWARD 1 -p udp -m mark --mark 0/${MARK_ANTISUB} \
        -m addrtype --dst-type unicast -m conntrack --ctstate NEW \
        -j NFQUEUE --queue-num ${SHIELD_QUEUE_NUM}
}

queue_owner()
{
    if [ "${UVM_PID}x" != "invalidx" ]; then return ; fi
    
    UVM_PID="invalid"
    
    if [ ! -f /proc/net/netfilter/nfnetlink_queue ] ; then return ; fi

    local t_queue_pid=`awk -v queue=0 '{ if ( $1 == queue ) print $2 }' /proc/net/netfilter/nfnetlink_queue`
    if [ -z "${t_queue_pid}" ]; then return ; fi
    
    UVM_PID=${t_queue_pid}  
}

## Function to determine if the UVM is running
is_uvm_running()
{
    queue_owner
    if [ "${UVM_PID}x" = "invalidx" ]; then return ; fi

    if [ ! -f "/proc/${UVM_PID}/cmdline" ]; then return ; fi
    
    grep -q com.untangle.uvm /proc/${UVM_PID}/cmdline 2>| /dev/null  && echo "true"
}

uvm_home()
{
    queue_owner
    
    if [ ! -f /proc/${UVM_PID}/cmdline ]; then return ; fi

    ## Ignore errors
    perl -pe 's/[^0-9=a-zA-Z\/\-\+\*\.]/\n/g' /proc/${UVM_PID}/cmdline 2>| /dev/null | \
        awk '/^-Duvm.home=/ { gsub( "-Duvm.home=", "" ) ; print }'
}
  
## This setting should always be disabled.
# this needs to be turned off when the interface is brought up
if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ] ; then
    echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
fi

## increment the UDP timeout to 60 seconds, kind of a hack to have this here.
if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout ]; then
    echo ${UDP_SESSION_TIMEOUT} > /proc/sys/net/netfilter/nf_conntrack_udp_timeout
fi

if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream ]; then
    echo 180 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream
fi

if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout ]; then
    echo ${UDP_SESSION_TIMEOUT} > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout
fi

if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream ]; then
    echo 180 > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream
fi

## Set the path for the uvm networking script
UVM_NETWORKING_CONFIG=`uvm_home`/conf/networking.sh

if [ ! -f ${UVM_NETWORKING_CONFIG} ]; then 
  echo "[`date`] '${UVM_NETWORKING_CONFIG}' does not exist."
  return 0
fi
 
. ${UVM_NETWORKING_CONFIG}

update_tcp_window_scaling()
{
    if [ -f /proc/sys/net/ipv4/tcp_window_scaling ] ; then
        ## If undefined or non-true, disable window scaling
        val=0
        
        if [ "x${TCP_WINDOW_SCALING_EN}" = "xtrue" ]; then
            echo "[DEBUG:`date`] enabling TCP Window Scaling"
            val=1
        fi
        
        echo $val > /proc/sys/net/ipv4/tcp_window_scaling
    fi
}

uvm_iptables_rules()
{    
    local t_address
    local t_tcp_port_range

    # Update the flag for TCP Window scaling.
    update_tcp_window_scaling

    # Do not conntrack entries in that have the NOTRACK bit set.
    ${IPTABLES} -A OUTPUT -t raw -m mark --mark ${MARK_NOTRACK}/${MARK_NOTRACK} -j NOTRACK


    # dont queue ICMP packets released from the queue.
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MARK_DUPE}/${MARK_DUPE} -j RETURN

    ## Don't mangle resets, for some reason the routing drops them if they
    ## get mangled.
    ${IPTABLES} -A OUTPUT -t mangle -j RETURN -p tcp --tcp-flags SYN,ACK,RST ACK,RST

    #dont queue anthing on output
    # mangling notracked packets from the raw socket causes the packets to
    # be silently dropped in routing.  so we need to let them pass
    ${IPTABLES} -A OUTPUT -t mangle -j MARK -m mark --mark 0/${MARK_NOTRACK} --or-mark ${MARK_ANTISUB}

    #dont queue anthing from localhost
    ${IPTABLES} -A PREROUTING -t mangle -i lo -j MARK --or-mark ${MARK_ANTISUB}

    #dont queue anthing that was liberated, or is connmarked antisubscribe
    ${IPTABLES} -A PREROUTING -t mangle -m connmark --mark ${MARK_ANTISUB}/${MARK_ANTISUB} -j MARK --or-mark  ${MARK_ANTISUB}
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MARK_ANTISUB}/${MARK_ANTISUB}  -j RETURN

    # Queue all of the ICMP packets (except for pings).
    ${IPTABLES} -A PREROUTING -t mangle -p icmp --icmp-type echo-request -j RETURN
    ${IPTABLES} -A PREROUTING -t mangle -p icmp --icmp-type echo-reply   -j RETURN
    ${IPTABLES} -A PREROUTING -t mangle -p icmp                          -j NFQUEUE

    #redirect  anthing re-injected packets from the TUN interface to us
    ## Add a redirect rule for each address,
    ${IPTABLES} -t nat -N "${LOCAL_UVM_REDIRECT}"
    ${IPTABLES} -t nat -F "${LOCAL_UVM_REDIRECT}"
    ${IPTABLES} -I PREROUTING 1 -t nat -i ${TUN_DEV} -p tcp -g "${LOCAL_UVM_REDIRECT}"
    for t_address in `ip -f inet addr show | awk '/^ *inet/ { sub( "/.*", "", $2 ) ; print $2 }'` ; do
        if [ "${t_address}" = "127.0.0.1" ]; then continue ; fi
        if [ "${t_address}" = "192.0.2.42" ]; then continue ; fi
        if [ "${t_address}" = "192.0.2.43" ]; then continue ; fi

        ${IPTABLES} -A "${LOCAL_UVM_REDIRECT}"  -t nat -i ${TUN_DEV} -t nat -p tcp \
            --destination ${t_address}  -j DNAT --to-destination ${t_address}:${TCP_REDIRECT_PORTS}
    done
    
    ${IPTABLES} -A "${LOCAL_UVM_REDIRECT}"  -t nat -i ${TUN_DEV} -t nat -p tcp \
        -j REDIRECT --to-ports ${TCP_REDIRECT_PORTS}

    ## Guard the ports (this part uses : not -)
    
    t_tcp_port_range=`echo ${TCP_REDIRECT_PORTS} | sed 's|-|:|'`
    ${IPTABLES} -t filter -I INPUT 1 ! -i utun -p tcp --destination-port ${t_tcp_port_range} \
        -m conntrack --ctstate NEW,INVALID -j DROP

    # when packets are released from the queue they restart at the top of the table.
    # we set this mark on them before releasing and catch conmark them so we wont catch the rest of the session 
    # or any related sesions from conntrack.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MARK_DUPE}/${MARK_DUPE} -j CONNMARK --set-mark ${MARK_ANTISUB} 

    # Ignore traffic that is related to a session we are not watching.
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate RELATED  -j RETURN

    # Ignore traffic that has no conntrack info because we cant NAT it.
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate INVALID  -j RETURN

    # Ignore traffic that we have antisubscribed to.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MARK_ANTISUB}/${MARK_ANTISUB}  -j RETURN

    # Queue all of the SYN packets.
    ${IPTABLES} -A POSTROUTING -t tune -p tcp --syn -j NFQUEUE

    # Queue all of the UDP packets.
    ${IPTABLES} -A POSTROUTING -t tune -m addrtype --dst-type unicast -p udp -j NFQUEUE

    ## Just in case these settings were lost.
    ifconfig dummy0 ${UVM_BIND_ADDRESS} netmask 255.255.255.0 up
    ifconfig ${TUN_DEV} ${TUN_ADDR} netmask 255.255.255.0 

    if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ]; then
        ifconfig ${TUN_DEV} up
        echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
    else
        echo "[`date`] ${TUN_DEV} device not exist."
    fi
}

## Create the rules to allow internal access to port 80.
uvm_packet_filter_standard_internal()
{
    local t_mark=$(( ${MARK_LOCAL} | 0x2 | ${MARK_FIRST_ALIAS} ))
    local t_mask
    local t_block_page_port=${UVM_BLOCK_PAGE_PORT:-80}

    if [ "${UVM_ALLOW_IN_HTTP}x" = "truex" ]; then 
        ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports 80 \
            -m mark --mark ${t_mark}/${t_mark} -j REDIRECT
        ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports 80 \
            -m mark --mark ${t_mark}/${t_mark} -j RETURN
    fi
    
    ## If all of the marks for the WAN interfaces are not set, then this came in on a
    ## non-wan interface.
    t_mask=$(( ${MARK_LOCAL} | ${MARK_FIRST_ALIAS} | ${MASK_WAN} ))
    t_mark=$(( ${MARK_LOCAL} | ${MARK_FIRST_ALIAS} ))
    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports ${t_block_page_port} \
        -m mark --mark ${t_mark}/${t_mask} -j REDIRECT --to-ports ${HTTP_INTERNAL_REDIRECT_PORT}
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports ${t_block_page_port} \
        -m mark --mark ${t_mark}/${t_mask} -j RETURN    
}


## Allow internal access to port.
uvm_packet_filter_secure_internal()
{
    local t_mark=$(( ${MARK_LOCAL} | ${MARK_FIRST_ALIAS} ))
    local t_mask=$(( ${MARK_LOCAL} | ${MASK_WAN} | ${MARK_FIRST_ALIAS} ))

    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports 443 \
        -m mark --mark ${t_mark}/${t_mask} \
        -j REDIRECT --to-ports ${HTTPS_INTERNAL_REDIRECT_PORT}
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports 443 \
        -m mark --mark ${t_mark}/${t_mask} -j RETURN

    if [ "${HTTPS_PUBLIC_PORT}x" = "x" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_ADDR}x" = "x" ] ; then return ; fi

    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        -m mark --mark 2/2 --destination-ports ${HTTPS_PUBLIC_PORT} \
        -j REDIRECT --to-ports ${HTTPS_INTERNAL_REDIRECT_PORT}
    
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        -m mark --mark 2/2 --destination-ports ${HTTPS_PUBLIC_PORT} -j RETURN
}

## This is a helper function to generate the necessary filter to restrict external access.
uvm_restrict_access_string()
{
    if [ "${UVM_ALLOW_OUT_RES}x" != "truex" ] ; then return ; fi
    
    if [ -z "${UVM_ALLOW_OUT_NET}" ] ; then return ; fi
    
    if [ -z "${UVM_ALLOW_OUT_MASK}" ] ; then return ; fi
    
    echo " -s ${UVM_ALLOW_OUT_NET}/${UVM_ALLOW_OUT_MASK} "
}

## Allow secure access to the external port,.
uvm_packet_filter_secure_external()
{
    local t_restrict
    local t_mark

    if [ "${UVM_ALLOW_OUT_HTTPS}x" != "truex" ] ; then return ; fi

    t_restrict=`uvm_restrict_access_string`
    
    t_mark=$(( ${MARK_LOCAL} | ${MARK_FIRST_ALIAS} ))
    
    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports ${HTTPS_EXTERNAL_PORT} \
        ${t_restrict} -m mark --mark ${t_mark}/${t_mark} -j REDIRECT --to-ports 443
    
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports ${HTTPS_EXTERNAL_PORT} \
        ${t_restrict} -m mark --mark ${t_mark}/${t_mark} -j RETURN
}

uvm_packet_filter_secure_public()
{
    if [ "${HTTPS_PUBLIC_REDIRECT_EN}x" != "truex" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_PORT}x" = "x" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_ADDR}x" = "x" ] ; then return ; fi


    ## This doesn't use the restricted address because it assumes the upstream
    ## router is doing the restrictions.

    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        --destination-ports ${HTTPS_PUBLIC_PORT} -j REDIRECT --to-ports 443
    
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        --destination-ports ${HTTPS_PUBLIC_PORT} -j RETURN
}

## You should only run this if openvpn is running, these rules will only apply to 
## packets that are bridged.

## Reroute all Bridge traffic destined to the VPN through the VPN.
uvm_openvpn_ebtables_rules()
{
    local t_network_list
    local t_network
    local t_bridge_list
    local t_bridge
    
    t_network_list=`ip route show dev tun0 scope global | awk '{ print $1}'`

    ## Nothing to do if there is no VPN traffic.
    test -z "${t_network_list}" && return

    t_bridge_list=`find /sys/class/net/*/bridge -name 'bridge_id' 2>/dev/null | sed -e 's|/sys/class/net/\([^/]*\)/.*|\1|'`
    
    test -z "${t_bridge_list}" && return
    
    ${EBTABLES} -t broute -N untangle-openvpn || true

    ## Add rules to go to the VPN table on all of the bridges.
    for t_bridge in ${t_bridge_list} ; do
        ${EBTABLES} -t broute -A BROUTING --logical-in ${t_bridge} -j untangle-openvpn
    done

    ## Redirect all VPN traffic locally
    for t_network in ${t_network_list}; do
        ${EBTABLES} -t broute -A untangle-openvpn -p ipv4 --ip-destination ${t_network} -j redirect
    done
}
