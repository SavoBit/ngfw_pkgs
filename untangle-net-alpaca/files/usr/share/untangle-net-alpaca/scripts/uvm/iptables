#!/bin/dash

## Function to determine the pid of the process that owns the queue

UVM_PID="invalid"

TUN_DEV=utun
TUN_ADDR="192.0.2.43"
MASK_BYPASS=$((0x01000000))
MASK_NOTRACK=$((0x02000000))
MASK_FIRST_ALIAS=$((0x10000000))
MASK_DUPE=$((0x20000000))
MASK_LOCAL=$((0x10000))
MASK_SRC_INTERFACE=$((0xff))
LOCAL_UVM_REDIRECT="uvm-tcp-redirect"

## Always set this just in case.
TCP_REDIRECT_PORTS="9500-9627"
HTTP_INTERNAL_REDIRECT_PORT="64156"
HTTPS_INTERNAL_REDIRECT_PORT="64157"
## This is the port the UVM is serving HTTPs on the external interface.
HTTPS_EXTERNAL_PORT="443"

## This is the address everything in the UVM binds to.
UVM_BIND_ADDRESS="192.0.2.42"

## UDP Session timeout
UDP_SESSION_TIMEOUT=70

uvm_shield_traffic()
{
    SHIELD_QUEUE_NUM=3001

    if [ -f /etc/default/untangle-shield ]; then 
        . /etc/default/untangle-shield
    fi

    local t_queue_pid=`awk -v queue=${SHIELD_QUEUE_NUM} '{ if ( $1 == queue ) print $2 }' /proc/net/netfilter/nfnetlink_queue`

    if [ -z "${t_queue_pid}" ]; then 
        echo "[`date`] The untangle-shield is not running. No rules inserted."
        return
    fi

    echo "[`date`] The untangle-shield is running. Inserting queue rules."

    ## Queue any TCP that is that is now bypassed (SYN packet only)
    ${IPTABLES} -t mangle -A FORWARD -p tcp -m mark --mark 0/${MASK_BYPASS} \
        -m conntrack --ctstate NEW \
        -j NFQUEUE --queue-num ${SHIELD_QUEUE_NUM}

    ## Queue all UDP packets that arent bypassed (first packet only)
    ${IPTABLES} -t mangle -A FORWARD -p udp -m mark --mark 0/${MASK_BYPASS} \
        -m addrtype --dst-type unicast -m conntrack --ctstate NEW \
        -j NFQUEUE --queue-num ${SHIELD_QUEUE_NUM}
}

queue_owner()
{
    if [ "${UVM_PID}x" != "invalidx" ]; then return ; fi
    
    UVM_PID="invalid"
    
    if [ ! -f /proc/net/netfilter/nfnetlink_queue ] ; then return ; fi

    local t_queue_pid=`awk -v queue=0 '{ if ( $1 == queue ) print $2 }' /proc/net/netfilter/nfnetlink_queue`
    if [ -z "${t_queue_pid}" ]; then return ; fi
    
    UVM_PID=${t_queue_pid}  
}

## Function to determine if the UVM is running
is_uvm_running()
{
    queue_owner
    if [ "${UVM_PID}x" = "invalidx" ]; then return ; fi

    if [ ! -f "/proc/${UVM_PID}/cmdline" ]; then return ; fi
    
    grep -q com.untangle.uvm /proc/${UVM_PID}/cmdline 2>| /dev/null  && echo "true"
}

uvm_home()
{
    queue_owner
    
    if [ ! -f /proc/${UVM_PID}/cmdline ]; then return ; fi

    ## Ignore errors
    HOME="`perl -pe 's/[^0-9=a-zA-Z\/\-\+\*\.]/\n/g' /proc/${UVM_PID}/cmdline 2>| /dev/null | awk '/^-Duvm.home=/ { gsub( "-Duvm.home=", "" ) ; print }'`"
    
    if [ -z "$HOME" ] ; then
       echo "/usr/share/untangle/"
    else
       echo $HOME
    fi     
}
  
## This setting should always be disabled.
# this needs to be turned off when the interface is brought up
if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ] ; then
    echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
fi

## increment the UDP timeout to 60 seconds, kind of a hack to have this here.
if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout ]; then
    echo ${UDP_SESSION_TIMEOUT} > /proc/sys/net/netfilter/nf_conntrack_udp_timeout
fi

if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream ]; then
    echo 180 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream
fi

if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout ]; then
    echo ${UDP_SESSION_TIMEOUT} > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout
fi

if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream ]; then
    echo 180 > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream
fi

## Set the path for the uvm networking script
UVM_NETWORKING_CONFIG=`uvm_home`/conf/networking.sh

if [ ! -f ${UVM_NETWORKING_CONFIG} ]; then 
  #echo "[`date`] '${UVM_NETWORKING_CONFIG}' does not exist."
  echo "[`date`] The untangle-vm is not running. No rules inserted."
  return 0
fi
 
. ${UVM_NETWORKING_CONFIG}

uvm_iptables_rules()
{    
    local t_address
    local t_tcp_port_range

    # Do not conntrack entries in that have the NOTRACK bit set.
    ${IPTABLES} -A OUTPUT -t raw -m mark --mark ${MASK_NOTRACK}/${MASK_NOTRACK} -j NOTRACK

    # Dont queue ICMP packets released from the queue.
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MASK_DUPE}/${MASK_DUPE} -j RETURN

    # Set the bypass bit so that the untangle-vm never re-queues its own output
    ${IPTABLES} -A OUTPUT -t mangle -j MARK --or-mark ${MASK_BYPASS}

    # Dont queue anthing from localhost
    ${IPTABLES} -A PREROUTING -t mangle -i lo -j MARK --or-mark ${MASK_BYPASS}

    # Dont queue anthing that was liberated, or is bypassed
    ${IPTABLES} -A PREROUTING -t mangle -m connmark --mark ${MASK_BYPASS}/${MASK_BYPASS} -j MARK --or-mark  ${MASK_BYPASS}
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MASK_BYPASS}/${MASK_BYPASS}  -j RETURN

    # Redirect any re-injected packets from the TUN interface to us
    ## Add a redirect rule for each address,
    ${IPTABLES} -t nat -N "${LOCAL_UVM_REDIRECT}" &> /dev/null
    ${IPTABLES} -t nat -F "${LOCAL_UVM_REDIRECT}"
    ${IPTABLES} -I PREROUTING 1 -t nat -i ${TUN_DEV} -p tcp -g "${LOCAL_UVM_REDIRECT}"
    for t_address in `ip -f inet addr show | awk '/^ *inet/ { sub( "/.*", "", $2 ) ; print $2 }'` ; do
        if [ "${t_address}" = "127.0.0.1" ]; then continue ; fi
        if [ "${t_address}" = "192.0.2.42" ]; then continue ; fi
        if [ "${t_address}" = "192.0.2.43" ]; then continue ; fi

        ${IPTABLES} -A "${LOCAL_UVM_REDIRECT}"  -t nat -i ${TUN_DEV} -t nat -p tcp \
            --destination ${t_address}  -j DNAT --to-destination ${t_address}:${TCP_REDIRECT_PORTS}
    done
    
    # Redirect TCP traffic to the local ports (where the untangle-vm is listening)
    ${IPTABLES} -A "${LOCAL_UVM_REDIRECT}"  -t nat -i ${TUN_DEV} -t nat -p tcp \
        -j REDIRECT --to-ports ${TCP_REDIRECT_PORTS}

    ## Guard the ports (this part uses : not -)
    t_tcp_port_range=`echo ${TCP_REDIRECT_PORTS} | sed 's|-|:|'`
    ${IPTABLES} -t filter -I INPUT 1 ! -i utun -p tcp --destination-port ${t_tcp_port_range} \
        -m conntrack --ctstate NEW,INVALID -j DROP

    # when packets are released from the queue they restart at the top of the table.
    # we set this mark on them before releasing and catch conmark them so we wont catch the rest of the session 
    # or any related sesions from conntrack.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MASK_DUPE}/${MASK_DUPE} -j CONNMARK --set-mark ${MASK_BYPASS} 

    # Ignore traffic that is related to a session we are not watching.
    # If its "related" according to iptables, then original session must have been bypassed
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate RELATED  -j RETURN

    # Ignore traffic that has no conntrack info because we cant NAT it.
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate INVALID  -j RETURN

    # Ignore bypassed traffic.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MASK_BYPASS}/${MASK_BYPASS}  -j RETURN

    # Queue all of the SYN packets.
    ${IPTABLES} -A POSTROUTING -t tune -p tcp --syn -j NFQUEUE

    # Queue all of the UDP packets.
    ${IPTABLES} -A POSTROUTING -t tune -m addrtype --dst-type unicast -p udp -j NFQUEUE

    ## Just in case these settings were lost.
    ifconfig dummy0 ${UVM_BIND_ADDRESS} netmask 255.255.255.0 up
    ifconfig ${TUN_DEV} ${TUN_ADDR} netmask 255.255.255.0 

    if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ]; then
        ifconfig ${TUN_DEV} up
        echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
    else
        echo "[`date`] ${TUN_DEV} device not exist."
    fi
}

## Create the rules to allow internal access to port 80.
uvm_packet_filter_standard_internal()
{
    # non-WAN HTTP administration rules
    /usr/share/untangle-net-alpaca/scripts/uvm/netConfig.py non_wan_idx | while read intfId ; do
        local t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | $intfId ))
    	local t_mask=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | ${MASK_SRC_INTERFACE} ))

        if [ "${UVM_ALLOW_IN_HTTP}x" = "truex" ]; then 
	    ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports 80 -m mark --mark ${t_mark}/${t_mask} -j REDIRECT
            ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports 80 -m mark --mark ${t_mark}/${t_mask} -j RETURN
        fi
    done	
    
    # non-WAN HTTP blockpage rules
    /usr/share/untangle-net-alpaca/scripts/uvm/netConfig.py non_wan_idx | while read intfId ; do
        local t_block_page_port=80 # now hardcoded at 80
        local t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | $intfId ))
    	local t_mask=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | ${MASK_SRC_INTERFACE} ))

        ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports ${t_block_page_port} -m mark --mark ${t_mark}/${t_mask} -j REDIRECT --to-ports ${HTTP_INTERNAL_REDIRECT_PORT}
        ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports ${t_block_page_port} -m mark --mark ${t_mark}/${t_mask} -j RETURN    
    done
}


## Allow internal access to port.
uvm_packet_filter_secure_internal()
{
    # non-WAN HTTPS administration rules
    /usr/share/untangle-net-alpaca/scripts/uvm/netConfig.py non_wan_idx | while read intfId ; do
        local t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | $intfId ))
        local t_mask=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | ${MASK_SRC_INTERFACE} ))

        ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports 443 -m mark --mark ${t_mark}/${t_mask} -j REDIRECT --to-ports ${HTTPS_INTERNAL_REDIRECT_PORT}
        ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports 443 -m mark --mark ${t_mark}/${t_mask} -j RETURN
    done

    if [ "${HTTPS_PUBLIC_PORT}x" = "x" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_ADDR}x" = "x" ] ; then return ; fi

    # WAN HTTPS administration rules
    /usr/share/untangle-net-alpaca/scripts/uvm/netConfig.py non_wan_idx | while read intfId ; do
        local t_mark=$(( $intfId ))
        local t_mask=$(( ${MASK_SRC_INTERFACE} ))

        ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} -m mark --mark ${t_mark}/${t_mask} --destination-ports ${HTTPS_PUBLIC_PORT} -j REDIRECT --to-ports ${HTTPS_INTERNAL_REDIRECT_PORT}
        ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} -m mark --mark ${t_mark}/${t_mask} --destination-ports ${HTTPS_PUBLIC_PORT} -j RETURN
    done
}

## This is a helper function to generate the necessary filter to restrict external access.
uvm_restrict_access_string()
{
    if [ "${UVM_ALLOW_OUT_RES}x" != "truex" ] ; then return ; fi
    
    if [ -z "${UVM_ALLOW_OUT_NET}" ] ; then return ; fi
    
    if [ -z "${UVM_ALLOW_OUT_MASK}" ] ; then return ; fi
    
    echo " -s ${UVM_ALLOW_OUT_NET}/${UVM_ALLOW_OUT_MASK} "
}

## Allow secure access to the external port,.
uvm_packet_filter_secure_external()
{
    local t_restrict
    local t_mark

    if [ "${UVM_ALLOW_OUT_HTTPS}x" != "truex" ] ; then return ; fi

    t_restrict=`uvm_restrict_access_string`
    t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} ))

    # all interfaces HTTPS administration rules
    ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports ${HTTPS_EXTERNAL_PORT} ${t_restrict} -m mark --mark ${t_mark}/${t_mark} -j REDIRECT --to-ports 443
    ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports ${HTTPS_EXTERNAL_PORT} ${t_restrict} -m mark --mark ${t_mark}/${t_mark} -j RETURN
}

uvm_packet_filter_secure_public()
{
    if [ "${HTTPS_PUBLIC_REDIRECT_EN}x" != "truex" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_PORT}x" = "x" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_ADDR}x" = "x" ] ; then return ; fi

    ## This doesn't use the restricted address because it assumes the upstream
    ## router is doing the restrictions.

    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        --destination-ports ${HTTPS_PUBLIC_PORT} -j REDIRECT --to-ports 443
    
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        --destination-ports ${HTTPS_PUBLIC_PORT} -j RETURN
}

## You should only run this if openvpn is running, these rules will only apply to 
## packets that are bridged.

## Reroute all Bridge traffic destined to the VPN through the VPN.
uvm_openvpn_ebtables_rules()
{
    local t_network_list
    local t_network
    local t_bridge_list
    local t_bridge
    
    t_network_list=`ip route show dev tun0 scope global | awk '{ print $1}'`

    ## Nothing to do if there is no VPN traffic.
    test -z "${t_network_list}" && return

    t_bridge_list=`find /sys/class/net/*/bridge -name 'bridge_id' 2>/dev/null | sed -e 's|/sys/class/net/\([^/]*\)/.*|\1|'`
    
    test -z "${t_bridge_list}" && return
    
    ${EBTABLES} -t broute -N untangle-openvpn || true

    ## Add rules to go to the VPN table on all of the bridges.
    for t_bridge in ${t_bridge_list} ; do
        ${EBTABLES} -t broute -A BROUTING --logical-in ${t_bridge} -j untangle-openvpn
    done

    ## Redirect all VPN traffic locally
    for t_network in ${t_network_list}; do
        ${EBTABLES} -t broute -A untangle-openvpn -p ipv4 --ip-destination ${t_network} -j redirect
    done
}
