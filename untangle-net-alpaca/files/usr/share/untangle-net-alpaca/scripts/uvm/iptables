#!/bin/dash

## Function to determine the pid of the process that owns the queue

UVM_PID="invalid"

TUN_DEV=utun

MARK_ANTISUB=$((0x01000000))
MARK_NOTRACK=$((0x02000000))
MARK_DUPE=$((0x20000000))

## Always set this just in case.
TCP_REDIRECT_PORTS="9500-9627"
HTTPS_INTERNAL_REDIRECT_PORT="64157"
## This is the port the UVM is serving HTTPs on the external interface.
HTTPS_EXTERNAL_PORT="443"

## This is the address everything in the UVM binds to.
UVM_BIND_ADDRESS="192.0.2.42"

queue_owner()
{
    if [ "${UVM_PID}x" != "invalidx" ]; then return ; fi
    
    UVM_PID="invalid"
    
    if [ ! -f /proc/net/netfilter/nfnetlink_queue ] ; then return ; fi

    local t_queue_pid=`awk '{ print $2 }' /proc/net/netfilter/nfnetlink_queue`
    if [ -z "${t_queue_pid}" ]; then return ; fi
    
    UVM_PID=${t_queue_pid}  
}

## Function to determine if the UVM is running
is_uvm_running()
{
    queue_owner
    if [ "${UVM_PID}x" = "invalidx" ]; then return ; fi

    if [ ! -f "/proc/${UVM_PID}/cmdline" ]; then return ; fi
    
    grep -q com.untangle.uvm /proc/${UVM_PID}/cmdline 2>| /dev/null  && echo "true"
}

bunnicula_home()
{
    queue_owner
    
    if [ ! -f /proc/${UVM_PID}/cmdline ]; then return ; fi

    ## Ignore errors
    perl -pe 's/[^0-9=a-zA-Z\/\-\+\*\.]/\n/g' /proc/${UVM_PID}/cmdline 2>| /dev/null | \
        awk '/^-Dbunnicula.home=/ { gsub( "-Dbunnicula.home=", "" ) ; print }'
}
  
## This setting should always be disabled.
# this needs to be turned off when the interface is brought up
if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ] ; then
    echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
fi

## increment the UDP timeout to 60 seconds, kind of a hack to have this here.
if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout ]; then
    echo 60 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout
fi

if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream ]; then
    echo 180 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream
fi

if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout ]; then
    echo 60 > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout
fi

if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream ]; then
    echo 180 > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream
fi

## Set the path for the bunnicula networking script
UVM_NETWORKING_CONFIG=`bunnicula_home`/conf/networking.sh

if [ ! -f ${UVM_NETWORKING_CONFIG} ]; then 
  echo "[`date`] '${UVM_NETWORKING_CONFIG}' does not exist."
  return 0
fi
 
. ${UVM_NETWORKING_CONFIG}

update_tcp_window_scaling()
{
    if [ -f /proc/sys/net/ipv4/tcp_window_scaling ] ; then
        ## If undefined or non-true, disable window scaling
        val=0
        
        if [ "x${TCP_WINDOW_SCALING_EN}" = "xtrue" ]; then
            echo "[DEBUG:`date`] enabling TCP Window Scaling"
            val=1
        fi
        
        echo $val > /proc/sys/net/ipv4/tcp_window_scaling
    fi
}

uvm_iptables_rules()
{    
    # Update the flag for TCP Window scaling.
    update_tcp_window_scaling

    # Do not conntrack entries in that have the NOTRACK bit set.
    ${IPTABLES} -A OUTPUT -t raw -m mark --mark ${MARK_NOTRACK}/${MARK_NOTRACK} -j NOTRACK


    # dont queue ICMP packets released from the queue.
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MARK_DUPE}/${MARK_DUPE} -j RETURN

    ## Don't mangle resets, for some reason the routing drops them if they
    ## get mangled.
    ${IPTABLES} -A OUTPUT -t mangle -j RETURN -p tcp --tcp-flags SYN,ACK,RST ACK,RST

    #dont queue anthing on output
    # mangling notracked packets from the raw socket causes the packets to
    # be silently dropped in routing.  so we need to let them pass
    ${IPTABLES} -A OUTPUT -t mangle -j MARK -m mark --mark 0/${MARK_NOTRACK} --or-mark ${MARK_ANTISUB}

    #dont queue anthing from localhost
    ${IPTABLES} -A PREROUTING -t mangle -i lo -j MARK --or-mark ${MARK_ANTISUB}

    #dont queue anthing that was liberated, or is connmarked antisubscribe
    ${IPTABLES} -A PREROUTING -t mangle -m connmark --mark ${MARK_ANTISUB}/${MARK_ANTISUB} -j MARK --or-mark  ${MARK_ANTISUB}
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MARK_ANTISUB}/${MARK_ANTISUB}  -j RETURN

    # Queue all of the ICMP packets (except for pings).
    ${IPTABLES} -A PREROUTING -t mangle -p icmp --icmp-type echo-request -j RETURN
    ${IPTABLES} -A PREROUTING -t mangle -p icmp --icmp-type echo-reply   -j RETURN
    ${IPTABLES} -A PREROUTING -t mangle -p icmp                          -j NFQUEUE

    #redirect  anthing re-injected packets from the TUN interface to us
    ${IPTABLES} -I PREROUTING 1 -t nat -i ${TUN_DEV} -t nat -p tcp \
        -j DNAT --to-destination ${UVM_BIND_ADDRESS}:${TCP_REDIRECT_PORTS}

    # when packets are released from the queue they restart at the top of the table.
    # we set this mark on them before releasing and catch conmark them so we wont catch the rest of the session 
    # or any related sesions from conntrack.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MARK_DUPE}/${MARK_DUPE} -j CONNMARK --set-mark ${MARK_ANTISUB} 

    # Ignore traffic that is related to a session we are not watching.
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate RELATED  -j RETURN

    # Ignore traffic that has no conntrack info because we cant NAT it.
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate INVALID  -j RETURN

    # Ignore traffic that we have antisubscribed to.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MARK_ANTISUB}/${MARK_ANTISUB}  -j RETURN

    # Queue all of the SYN packets.
    ${IPTABLES} -A POSTROUTING -t tune -p tcp --syn -j NFQUEUE

    # Queue all of the UDP packets.
    ${IPTABLES} -A POSTROUTING -t tune -m addrtype --dst-type unicast -p udp -j NFQUEUE

    ## Just in case these settings were lost.
    ifconfig dummy0 ${UVM_BIND_ADDRESS} netmask 255.255.255.0 up
    if [ -f /proc/sys/net/ipv4/conf/utun/rp_filter ]; then
        ifconfig utun up
        echo 0 > /proc/sys/net/ipv4/conf/utun/rp_filter
    else
        echo "[`date`] utun device not exist."
    fi
}

## Create the rules to allow internal access to port 80.
uvm_packet_filter_standard_internal()
{
    if [ "${UVM_ALLOW_IN_HTTP}x" != "truex" ]; then return ; fi

    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports 80 \
        -m mark --mark 2050/2050 -j DNAT --to-destination ${UVM_BIND_ADDRESS}
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports 80 \
        -m mark --mark 2050/2050 -j RETURN
}

## Allow internal access to port.
uvm_packet_filter_secure_internal()
{
    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports 443 \
        -m mark --mark 2050/2050 -j DNAT --to-destination ${UVM_BIND_ADDRESS}:${HTTPS_INTERNAL_REDIRECT_PORT}
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports 443 \
        -m mark --mark 2050/2050 -j RETURN
}

## This is a helper function to generate the necessary filter to restrict external access.
uvm_restrict_access_string()
{
    if [ "${UVM_ALLOW_OUT_RES}x" != "truex" ] ; then return ; fi
    
    if [ -z "${UVM_ALLOW_OUT_NET}" ] ; then return ; fi
    
    if [ -z "${UVM_ALLOW_OUT_MASK}" ] ; then return ; fi
    
    echo " -s ${UVM_ALLOW_OUT_NET}/${UVM_ALLOW_OUT_MASK} "
}

## Allow secure access to the external port,.
uvm_packet_filter_secure_external()
{
    local t_restrict
    if [ "${UVM_ALLOW_OUT_HTTPS}x" != "truex" ] ; then return ; fi

    t_restrict=`uvm_restrict_access_string`
    
    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport --destination-ports ${HTTPS_EXTERNAL_PORT} \
        ${t_restrict} -m mark --mark 2048/2048 -j DNAT --to-destination ${UVM_BIND_ADDRESS}:443
    
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport --destination-ports ${HTTPS_EXTERNAL_PORT} \
        ${t_restrict} -m mark --mark 2048/2048 -j RETURN
}

uvm_packet_filter_secure_public()
{
    if [ "${HTTPS_PUBLIC_REDIRECT_EN}x" != "truex" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_PORT}x" = "x" ] ; then return ; fi

    if [ "${HTTPS_PUBLIC_ADDR}x" = "x" ] ; then return ; fi


    ## This doesn't use the restricted address because it assumes the upstream
    ## router is doing the restrictions.

    ${IPTABLES} -t nat -A alpaca-redirect -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        --destination-ports ${HTTPS_PUBLIC_PORT} -j DNAT --to-destination ${UVM_BIND_ADDRESS}:443
    
    ${IPTABLES} -t mangle -A firewall-rules -p tcp -m multiport -d ${HTTPS_PUBLIC_ADDR} \
        --destination-ports ${HTTPS_PUBLIC_PORT} -j RETURN
}

