#!/bin/dash

UVM_PID="invalid"

TUN_DEV=utun
TUN_ADDR="192.0.2.43"
MASK_BYPASS=$((0x01000000))
MASK_NOTRACK=$((0x02000000))
MASK_FIRST_ALIAS=$((0x10000000))
MASK_DUPE=$((0x20000000))
MASK_LOCAL=$((0x10000))
MASK_SRC_INTERFACE=$((0xff))
LOCAL_UVM_REDIRECT="uvm-tcp-redirect"

## Always set this just in case.
TCP_REDIRECT_PORTS="9500-9627"
## This is the port the UVM is serving HTTPs on the external interface.
HTTPS_PORT="443"

## This is the address everything in the UVM binds to.
UVM_BIND_ADDRESS="192.0.2.42"

## UDP Session timeout
UDP_SESSION_TIMEOUT=70

## Function to determine the pid of the process that owns the queue
queue_owner()
{
    if [ "${UVM_PID}x" != "invalidx" ]; then return ; fi
    
    UVM_PID="invalid"
    
    if [ ! -f /proc/net/netfilter/nfnetlink_queue ] ; then return ; fi

    local t_queue_pid=`awk -v queue=0 '{ if ( $1 == queue ) print $2 }' /proc/net/netfilter/nfnetlink_queue`
    if [ -z "${t_queue_pid}" ]; then return ; fi
    
    UVM_PID=${t_queue_pid}  
}

## Function to determine if the UVM is running
is_uvm_running()
{
    queue_owner
    if [ "${UVM_PID}x" = "invalidx" ]; then return ; fi

    if [ ! -f "/proc/${UVM_PID}/cmdline" ]; then return ; fi
    
    grep -q com.untangle.uvm /proc/${UVM_PID}/cmdline 2>| /dev/null  && echo "true"
}

## Function to return uvm home dir (works in dev and prod env)
uvm_home()
{
    queue_owner
    
    if [ ! -f /proc/${UVM_PID}/cmdline ]; then return ; fi

    ## Ignore errors
    HOME="`perl -pe 's/[^0-9=a-zA-Z\/\-\+\*\.]/\n/g' /proc/${UVM_PID}/cmdline 2>| /dev/null | awk '/^-Duvm.home=/ { gsub( "-Duvm.home=", "" ) ; print }'`"

    if [ -z "$HOME" ] ; then
       echo "/usr/share/untangle/"
    else
       echo $HOME
    fi     
}

## Sets all proc variables to appropriate values
set_proc_vars() 
{  
    ## This setting should always be disabled.
    # this needs to be turned off when the interface is brought up
    if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ] ; then
        echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
    fi

    ## increment the UDP timeout to 60 seconds, kind of a hack to have this here.
    if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout ]; then
        echo ${UDP_SESSION_TIMEOUT} > /proc/sys/net/netfilter/nf_conntrack_udp_timeout
    fi

    if [ -f /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream ]; then
        echo 180 > /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream
    fi

    if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout ]; then
        echo ${UDP_SESSION_TIMEOUT} > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout
    fi

    if [ -f /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream ]; then
        echo 180 > /proc/sys/net/ipv4/netfilter/ip_conntrack_udp_timeout_stream
    fi
}

uvm_iptables_rules()
{    
    local t_address
    local t_tcp_port_range

    # Do not conntrack entries in that have the NOTRACK bit set.
    ${IPTABLES} -A OUTPUT -t raw -m mark --mark ${MASK_NOTRACK}/${MASK_NOTRACK} -j NOTRACK

    # Dont queue ICMP packets released from the queue.
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MASK_DUPE}/${MASK_DUPE} -j RETURN

    # Set the bypass bit so that the untangle-vm never re-queues its own output
    ${IPTABLES} -A OUTPUT -t mangle -j MARK --or-mark ${MASK_BYPASS}

    # Dont queue anthing from localhost
    ${IPTABLES} -A PREROUTING -t mangle -i lo -j MARK --or-mark ${MASK_BYPASS}

    # Dont queue anthing that was liberated, or is bypassed
    ${IPTABLES} -A PREROUTING -t mangle -m connmark --mark ${MASK_BYPASS}/${MASK_BYPASS} -j MARK --or-mark  ${MASK_BYPASS}
    ${IPTABLES} -A PREROUTING -t mangle -m mark --mark ${MASK_BYPASS}/${MASK_BYPASS}  -j RETURN

    # Redirect any re-injected packets from the TUN interface to us
    ## Add a redirect rule for each address,
    ${IPTABLES} -t nat -N "${LOCAL_UVM_REDIRECT}" &> /dev/null
    ${IPTABLES} -t nat -F "${LOCAL_UVM_REDIRECT}"
    ${IPTABLES} -I PREROUTING 1 -t nat -i ${TUN_DEV} -p tcp -g "${LOCAL_UVM_REDIRECT}"
    for t_address in `ip -f inet addr show | awk '/^ *inet/ { sub( "/.*", "", $2 ) ; print $2 }'` ; do
        if [ "${t_address}" = "127.0.0.1" ]; then continue ; fi
        if [ "${t_address}" = "192.0.2.42" ]; then continue ; fi
        if [ "${t_address}" = "192.0.2.43" ]; then continue ; fi

        ${IPTABLES} -A "${LOCAL_UVM_REDIRECT}"  -t nat -i ${TUN_DEV} -t nat -p tcp --destination ${t_address}  -j DNAT --to-destination ${t_address}:${TCP_REDIRECT_PORTS}
    done
    
    # Redirect TCP traffic to the local ports (where the untangle-vm is listening)
    ${IPTABLES} -A "${LOCAL_UVM_REDIRECT}"  -t nat -i ${TUN_DEV} -t nat -p tcp -j REDIRECT --to-ports ${TCP_REDIRECT_PORTS}

    ## Guard the ports (this part uses : not -)
    t_tcp_port_range=`echo ${TCP_REDIRECT_PORTS} | sed 's|-|:|'`
    ${IPTABLES} -t filter -I INPUT 1 ! -i utun -p tcp --destination-port ${t_tcp_port_range} -m conntrack --ctstate NEW,INVALID -j DROP

    # when packets are released from the queue they restart at the top of the table.
    # we set this mark on them before releasing and catch conmark them so we wont catch the rest of the session 
    # or any related sesions from conntrack.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MASK_DUPE}/${MASK_DUPE} -j CONNMARK --set-mark ${MASK_BYPASS} 

    # Ignore traffic that is related to a session we are not watching.
    # If its "related" according to iptables, then original session must have been bypassed
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate RELATED  -j RETURN

    # Ignore traffic that has no conntrack info because we cant NAT it.
    ${IPTABLES} -A POSTROUTING -t tune -m conntrack --ctstate INVALID  -j RETURN

    # Ignore bypassed traffic.
    ${IPTABLES} -A POSTROUTING -t tune -m mark --mark ${MASK_BYPASS}/${MASK_BYPASS}  -j RETURN

    # Queue all of the SYN packets.
    ${IPTABLES} -A POSTROUTING -t tune -p tcp --syn -j NFQUEUE

    # Queue all of the UDP packets.
    ${IPTABLES} -A POSTROUTING -t tune -m addrtype --dst-type unicast -p udp -j NFQUEUE

    ## Just in case these settings were lost.
    ifconfig dummy0 ${UVM_BIND_ADDRESS} netmask 255.255.255.0 up
    ifconfig ${TUN_DEV} ${TUN_ADDR} netmask 255.255.255.0 

    if [ -f /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter ]; then
        ifconfig ${TUN_DEV} up
        echo 0 > /proc/sys/net/ipv4/conf/${TUN_DEV}/rp_filter
    else
        echo "[`date`] ${TUN_DEV} device not exist."
    fi
}

## Create the rules to allow internal access to port 80.
uvm_insert_non_wan_HTTP_rules()
{
    # non-WAN HTTP rules
    /usr/share/untangle-net-alpaca/scripts/uvm/netConfig.py non_wan_idx | while read intfId ; do
        local t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | $intfId ))
    	local t_mask=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | ${MASK_SRC_INTERFACE} ))

        echo "[`date`] Enabling HTTP blockpages on interface $intfId." 
        ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports 80 -m mark --mark ${t_mark}/${t_mask} -j RETURN
        ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports 80 -m mark --mark ${t_mark}/${t_mask} -j RETURN    
    done
}

# deprecated NAME
uvm_packet_filter_standard_internal()
{
    uvm_insert_non_wan_HTTP_rules
}

## Allow internal access to port.
uvm_insert_non_wan_HTTPS_rules()
{
    HTTPS_PORT="`/usr/share/untangle/bin/ut-settings-reader.py -l -d 443 uvm system httpsPort`"
    if [ -z "${HTTPS_PORT}" ] ; then
        HTTPS_PORT="443"
    fi

    # non-WAN HTTPS administration rules (these assure that HTTPS administration is always reachable from non-WANs)
    /usr/share/untangle-net-alpaca/scripts/uvm/netConfig.py non_wan_idx | while read intfId ; do
        # This has been changed to just LOCAL | src_intf
        # For example, if 1.2.3.4 is the external IP, these rules assure https://1.2.3.4:HTTPS_PORT/ is reachable from the non-WANs
        #local t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | $intfId ))
        #local t_mask=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} | ${MASK_SRC_INTERFACE} ))
        local t_mark=$(( ${MASK_LOCAL} | $intfId ))
        local t_mask=$(( ${MASK_LOCAL} | ${MASK_SRC_INTERFACE} ))

        echo "[`date`] Enabling HTTPS administration on interface $intfId. Port: ${HTTPS_PORT}" 
        ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports ${HTTPS_PORT} -m mark --mark ${t_mark}/${t_mask} -j REDIRECT --to-ports 443
        ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports ${HTTPS_PORT} -m mark --mark ${t_mark}/${t_mask} -j RETURN
    done
}

# deprecated NAME
uvm_packet_filter_secure_internal()
{
    uvm_insert_non_wan_HTTPS_rules
}

## Allow secure access to the external port,.
uvm_insert_wan_HTTPS_rules()
{
    local t_mark

    FLAG_IS_OUTSIDE_HTTPS_ENABLED="`/usr/share/untangle/bin/ut-settings-reader.py -l uvm system outsideHttpsEnabled`"
    if [ "${FLAG_IS_OUTSIDE_HTTPS_ENABLED}x" != "truex" ] ; then return ; fi

    HTTPS_PORT="`/usr/share/untangle/bin/ut-settings-reader.py -l -d 443 uvm system httpsPort`"
    if [ -z "${HTTPS_PORT}" ] ; then
        HTTPS_PORT="443"
    fi

    t_mark=$(( ${MASK_LOCAL} | ${MASK_FIRST_ALIAS} ))

    # all interfaces HTTPS administration rules
    echo "[`date`] Enabling HTTPS administration on all interfaces. Port: ${HTTPS_PORT}" 
    ${IPTABLES} -t nat    -A alpaca-redirect -p tcp -m multiport --destination-ports ${HTTPS_PORT} -m mark --mark ${t_mark}/${t_mark} -j REDIRECT --to-ports 443
    ${IPTABLES} -t mangle -A firewall-rules  -p tcp -m multiport --destination-ports ${HTTPS_PORT} -m mark --mark ${t_mark}/${t_mark} -j RETURN
}

# deprecated NAME
uvm_packet_filter_secure_external()
{
    uvm_insert_wan_HTTPS_rules
}

## You should only run this if openvpn is running, these rules will only apply to 
## packets that are bridged.
## Reroute all Bridge traffic destined to the VPN through the VPN.
uvm_openvpn_ebtables_rules()
{
    local t_network_list
    local t_network
    local t_bridge_list
    local t_bridge
    
    t_network_list=`ip route show dev tun0 scope global | awk '{ print $1}'`

    ## Nothing to do if there is no VPN traffic.
    test -z "${t_network_list}" && return

    t_bridge_list=`find /sys/class/net/*/bridge -name 'bridge_id' 2>/dev/null | sed -e 's|/sys/class/net/\([^/]*\)/.*|\1|'`
    
    test -z "${t_bridge_list}" && return
    
    ${EBTABLES} -t broute -N untangle-openvpn || true

    ## Add rules to go to the VPN table on all of the bridges.
    for t_bridge in ${t_bridge_list} ; do
        ${EBTABLES} -t broute -A BROUTING --logical-in ${t_bridge} -j untangle-openvpn
    done

    ## Redirect all VPN traffic locally
    for t_network in ${t_network_list}; do
        ${EBTABLES} -t broute -A untangle-openvpn -p ipv4 --ip-destination ${t_network} -j redirect
    done
}
