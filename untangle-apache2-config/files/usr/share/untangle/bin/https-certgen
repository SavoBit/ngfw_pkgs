#!/bin/dash

OPENSSL_CONF="/usr/share/untangle/conf/https-openssl.cnf"
OPENSSL_TOOL="/usr/bin/openssl"
CERT_PATH="/var/cache/untangle-https"
TEMP="/dev/shm"

UT_ROOT_PATH="/usr/share/untangle/settings/untangle-certificates"

# Since we call this script to generate mitm certificates on the fly we must
# use a random source that will not block.  All the security articles I found
# indicate /dev/urandom has plenty of entropy given what we're doing here.
RANDFILE="/dev/urandom"

show_usage()
{
echo " "
echo "  USAGE: https-certgen certfile subject [ alternates ]"
echo " "
echo "  certfile = www.domain.com"
echo "  subject = /C=US/ST=California/L=Sunnyvale/O=Untangle/OU=Security/CN=www.domain.com"
echo "  alternates = DNS:ftp.domain.com,DNS:mail.domain.com"
echo " "
}

# First argument should be the destination filename for the new cert.  Since
# the origin cert CN might include a wildcard, the Java code will first
# convert the filename to all lower case and the replace any *'s with X's
if [ -z "$1" ]; then
    show_usage
    exit 1
fi

# Second argument should be the subject field for the generated certificate
if [ -z "$2" ]; then
    show_usage
    exit 2
fi

# Third argument is the optional string to be placed in the certificate
# subjectAlternativeName field.  When provided, we use a special CA section
# in the openssl.conf file that will include the list in the generated
# certificate.  When absent, we use a different CA section without the
# extension.  We have to define something in both cases since openssl will
# throw an error trying to read an empty environment variable even for
# config sections that aren't actually used.
if [ ! -z "$3" -a "$3" != "" ]; then
    UT_ROOT_MODE="CA_sanlist"
    UT_SAN_LIST="$3"
else
    UT_ROOT_MODE="CA_onehost"
    UT_SAN_LIST="empty"
fi

# export all environment variables referenced in our openssl config file
export UT_ROOT_PATH
export UT_ROOT_MODE
export UT_SAN_LIST
export RANDFILE

# if either of the root certificate files are missing we bail
if [ ! -r $UT_ROOT_PATH/untangle.key -o ! -r $UT_ROOT_PATH/untangle.crt ]; then
    echo "Unable to locate the root certificate authority files"
    exit 3
fi

# make sure the destination path for certificates exists
if [ ! -r $CERT_PATH ]; then
    mkdir -p $CERT_PATH
fi

SERIAL=`cat $UT_ROOT_PATH/serial.txt`

# The CA is ready to go so we create a certificate signing request
$OPENSSL_TOOL req -batch -nodes -config $OPENSSL_CONF -newkey rsa:2048 -keyout $TEMP/server.key -out $TEMP/server.csr -subj "$2"

# Next we sign the CSR with our CA cert and key
$OPENSSL_TOOL ca -batch -config $OPENSSL_CONF -policy policy_anything -startdate 100102030405Z -enddate 380102030405Z -out $TEMP/server.crt -outdir $TEMP -infiles $TEMP/server.csr

if [ "$1" = "APACHE" ]; then
    # special case when generating the Apache server certificate
    mkdir -p /etc/apache2/ssl
    cp $TEMP/server.key /etc/apache2/ssl/apache.pem
    grep -A 1000 BEGIN $TEMP/server.crt >> /etc/apache2/ssl/apache.pem
else
    # for all other put the signed server key and cert into a PKCS12 file
    $OPENSSL_TOOL pkcs12 -passout pass:password -export -name default -in $TEMP/server.crt -inkey $TEMP/server.key -out "$CERT_PATH/$1"
fi

# Cleanup the working files we created
rm -f $TEMP/server.key
rm -f $TEMP/server.csr
rm -f $TEMP/server.crt
rm -f $TEMP/$SERIAL.pem

