class OSLibrary::Debian::NetworkManager < OSLibrary::NetworkManager
  include Singleton

  Service = "/etc/init.d/networking"
  InterfacesConfigFile = "/etc/network/interfaces"
  InterfacesStatusFile = "/etc/network/ifstate"

  def interfaces
    logger.debug( "Running inside of the network manager for debian" )

    interfaceArray = []

    devices=`find /sys/devices -name 'net:*' | sed 's|.*net:||'`

    ## This is test code to fake a third interface
    devices << "dummy0" if File.exists?( "/sys/class/net/dummy0" )

    devices.each do |os_name|
      os_name = os_name.strip

      bus_id=""
      mac_address = File.open( "/sys/class/net/#{os_name}/address", "r" ) { |f| f.readline.strip }

      interfaceArray << PhysicalInterface.new( os_name, mac_address, bus_id )
    end
    
    interfaceArray
  end

  def commit
    interfaces_file = []
    interfaces_file << header
    Interface.find( :all ).each do |interface| 
      case interface.config_type
      when InterfaceHelper::ConfigType::STATIC
        interfaces_file << static( interface )
      when InterfaceHelper::ConfigType::DYNAMIC
        interfaces_file << dynamic( interface )
      when InterfaceHelper::ConfigType::BRIDGE
        interfaces_file << bridge( interface )
      end
    end

    ## Just write out the file for now.
    File.open( InterfacesConfigFile, "w" ) { |f| f.print( interfaces_file.join( "\n" )) }
    
    ## Restart networking
    ## Clear out all of the interface state.
    File.open( InterfacesStatusFile, "w" ) { |f| f.print( "lo=lo" ) }

    raise "Unable to reconfigure network settings" unless Kernel.system( "#{Service} restart" )
  end

  ## Dump out the configuration for a statically configured interface.
  def static( interface )
    ## Index of the interface that is being configured (nil for th first one)
    i = nil

    ## name of the interface
    name = interface.os_name
        
    bridge = bridgeSettings( interface )

    name = "br.#{name}" unless bridge.nil?
    
    static = interface.intf_static
    
    if static.nil?
      logger.warn( "The interface #{interface} is not configured" )
      return ""
    end

    ## Configure each IP and then join it all together with some newlines.
    interface.intf_static.ip_networks.map do |ip_network|
      ip_network_name = "#{name}#{i.nil? ? "" : ":#{i}"}"
      i = i.nil? ? 0 : i + 1

      base = <<EOF
auto #{ip_network_name}
iface #{ip_network_name} inet static
\taddress #{ip_network.ip}
\tnetmask #{OSLibrary::NetworkManager.parseNetmask( ip_network.netmask)}
EOF
      ## Only add the bridge stuff once
      base += bridge unless bridge.nil?
      bridge = nil
      
      
      base
    end.join( "\n" )
  end

  def dynamic( interface )
    ""
  end

  def bridge( interface )
    logger.debug( "Nothing needed for the bridge interface" )
    ""
  end

  ## These are the settings that should be appended to the first
  ## interface index that is inside of the interface (if this is in fact a bridge)
  def bridgeSettings( interface )
    ## Check if this is a bridge
    bridged_interfaces = interface.bridged_interfaces
    
    ## Create a new set of bridged interfaces
    bridged_interfaces = bridged_interfaces.map { |ib| ib.interface }.delete_if { |ib| ib.nil? }

    ## If this is nil or empty, it is not a bridge.    
    return nil if ( bridged_interfaces.nil? || bridged_interfaces.empty? )
    
    ## Append this interface
    bridged_interfaces << interface

    <<EOF
\turchin_bridge_ports #{bridged_interfaces.map{ |i| i.os_name }.join( " " )}
\turchin_debug true
\tbridge_ageing 900
EOF
  end

  def header
    <<EOF
## Auto Generated by the Untangle Net Urchin
## If you modify this file manually, your changes
## may be overriden

auto cleanup
iface cleanup inet manual
\turchin_debug true

## Configuration for the loopback interface
auto lo
iface lo inet loopback
EOF
  end
end
