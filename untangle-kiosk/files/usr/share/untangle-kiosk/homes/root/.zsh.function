alarm() {
  echo $@ | osd_cat -c green --delay 5 --align center --pos middle --font -b\&h-lucida-bold-r-normal-sans-34-240-100-100-p-216-iso8859-1 &
}

backupHistory() {
  local topBackupDir=~/.zsh_hist
  local backupDir=$topBackupDir/`hostname`
  local backupFileBasename="zsh_history"
  local backupFileBasePath=${backupDir}/${backupFileBasename}
  local backupFile=${backupFileBasePath}-`date --iso-8601=seconds`
  # save a copy
  mkdir -p -m 0700 $topBackupDir
  mkdir -p -m 0700 $backupDir
  cp ~/.zsh_history ${backupFile}
  # now remove all but latest 5
  local -a files
  files=(`find ${backupDir} -name "${backupFileBasename}*" | sort`)
  rm -f $files[1,-6]
}

bak() {
  cp -rP "${1}" "${1}.bak"
}
unbak() {
  cp -rP "${1}" "${1/.bak}"
}

beep() {
 echo -n "\a"
 n=${1:-1}
 if [[ $n -gt 1 ]] ; then
   for i in {2..${n}} ; do
     sleep .5
     echo -n "\a"     
   done
 fi
}

burn() {
  mkisofs -JR -f "$@" | s cdrecord -v -v driveropts=burnfree gracetime=2 -overburn -eject -
}

calc() {
  awk 'BEGIN { OFMT="%f"; print '"$*"'}'
}

cdc() {
  mkdir -p "$1" && cd "$1"
}

connect() { # pops an ssh windows if under x, or simple ssh if not
  local host=$1 && shift
  update-gpg-agent-tty
  [[ -n "$1" ]] && local port="-p $1" && shift
  if [[ -z "$@" ]] ; then
    xpop "ssh -Y $port $host" "$host" -g 161x54
  else
    xpop "ssh -Y $port $host" "$host" "$@"
  fi      
}

cp-other() {
  tar cf - "$1" | (cd $2 ; tar xfp -)
}

debian-doc() {
  zmore /usr/share/doc/$1/$2
}

debuild() {
  command debuild -i $@ --lintian-opts -viI
}

disable-command() {
  local command=$1
  shift
  "$command"() {
    if setopt | G -q "interactive .*on" ; then
      print "bleh"
    else
      $command "$@"
    fi
  }
}

dus() {
  du -s "$@" | sort -n
}

e-clean() {
  local dir=${1:-.}
  local files
  files=(${dir}/**/*~(DN) ${dir}/**/*.pyc(N) ${dir}/**/(.|)'#'*(N))
  (( $#files > 0 )) && /bin/rm -f $files
}

eas() { # Edit And Source
  ${EDITOR_ZSH} $@ && zreload
}

evaluate-command() { 
  # If param is a function, returns the array:
  #    ( "param() { actualDefinition }", param )
  # else, return an array containing the command + options, for instance
  #    ( ls -F --color )
  # The result is returned via $reply
  local command=$1
  if whence -v $command | grep -q "function" ; then
    # join function def. lines with ' ;'
    functionDef=${(pj: ;:)${(f)"$(whence -f $command)"}}
    # add a call to that function in the end
    reply="$functionDef ; $command"
  elif whence $command > /dev/null ; then # alias or command in PATH: put all elements in an array
    set -A reply `whence $command`
  elif \ls -l $command 2> /dev/null | egrep -q '^-..x' ; then # binary
    set -A reply $command
  else # not found
    return 1
  fi
}

# find() { # filter out .svn
#   dir=${1:-.}
#   [ $# -gt 0 ] && shift
#   local printArg
#   [[ "$@" == *-print* ]] || printArg="-print" 
#   command find "$dir" -path '*/.svn' -prune -o $@ $printArg
# }

grepz() {
  grep -H "$@" $ZSH_CONFIG_FILES .svn-*/.zsh_*(N)
}

have() {
  whence $1 > /dev/null
}

keychain-init-real() {
#  setopt localoptions xtrace
  # cleanup
  for e in GPG_AGENT_INFO SSH_AUTH_SOCK ; do
    rm -fr `echo $e`
    unset $e
  done
  unset SSH_AGENT_PID GPG_TTY
  pkill keychain
  pkill -9 keychain
  rm -fr ~/.keychain/${HOST}-*
  # start
  keychain --agents gpg --nogui --quiet --nocolor `gpg --list-secret-keys | awk '/^sec/ { gsub(/.+\//, "", $2) ; print $2 }'`
  rename -f "s|/S.gpg|/${HOST}-S.gpg|" ~/.gnupg/S*(=)
  perl -i -pe "s|/S.gpg|/${HOST}-S.gpg|" "$HOME/.keychain/${HOST}-sh-gpg"
}

keychain-init() {
#  setopt localoptions xtrace
  local SH_FILE="$HOME/.keychain/${HOST}-sh-gpg"
  if [ -f $SH_FILE ] &&  then
    source $SH_FILE
    if [ -z "$SSH_AGENT_PID" ] || [ ! -d /proc/$SSH_AGENT_PID ] ; then
      keychain-init-real
    fi
  else
    keychain-init-real
  fi
  source $SH_FILE

  export GPG_TTY=`tty`
  local key
  for key in ~/.ssh/*.[dr]sa(DN) ; do
    ssh-add -l | G $key DN || ssh-add $key
  done
}

lsd() {
  ll -d ${1}*(/)
}

lst() { # list files by type
  local type=$1
  shift
  if [[ ${+extensions[$type]} -eq 0 ]] ; then
    echo -n "$type is not a supported type. Valid types are: "
    echo ${(k)extensions[@]}
  fi
  local p
  if [[ ${#argv} -eq 0 ]] || [[ $argv[-1] == -** ]] ; then # no path was specified, use .
    p=.
  else
    p="$argv[-1]"
    argv=$argv[1,-2]
  fi
  local matches="`echo \"$p\"/*.${(s, ,)${extensions[$type]}}(DN)`"
  [[ -n "$matches" ]] && ls $argv "$p"/*.${(s, ,)${extensions[$type]}}(DN)
}

mvc() {
  mkdir -p "$argv[-1]" ; mv $@
}

nth () {
  local number=$1
  local pattern=${2:-.}
  awk "/${pattern}/ {print \$${number}}"
}

psc() {
  ps --cols=1000 --sort='-%cpu,uid,pgid,ppid,pid' -e \
     -o user,pid,ppid,pgid,stime,stat,wchan,time,pcpu,pmem,vsz,rss,sz,args |
     sed 's/^/ /' | less
}

psm() {
  ps --cols=1000 --sort='-vsz,uid,pgid,ppid,pid' -e \
     -o user,pid,ppid,pgid,stime,stat,wchan,time,pcpu,pmem,vsz,rss,sz,args |
     sed 's/^/ /' | less
}

psg() {
  psall | grep -v "grep -iE $1" | grep -iE "$1"
}

removeHost() { 
  perl -i.bak -ne 'print unless m/(ssh|connect|run) '"$1"'( |$)/' ~/.zsh_history
}

rmdeb() {
  \rm -f ${1:-.}/*.{changes,deb,orig.tar.gz,upload,dsc,build,diff.gz}(DN)
}

# rmmod() {
#   lsmod | grep -E "$1" | awk '{print $1}' | xargs rmmod
# }

round() {
  echo "scale=${2:-2};${1}/1" | bc
}

run() { # remotely run
  while getopts c OPTION ; do
    case $OPTION in
      c) local CONSOLE=1 ;;
      *) echo "blah" $OPTION ; return 1 ;;
    esac
  done

  shift $[ $OPTIND - 1 ]

  local host=$1
  local command=$2
  shift ; shift

  if [[ -n "${CONSOLE}" ]] ; then
    ssh -X -t $host $command
  else
    xpop "ssh -t $host \"$command\"" "RemoteExec@$host: $command" $@
  fi
}

s() { # smarter sudo
  [[ $1 = -d ]] && setopt localoptions xtrace && shift

  opts=()
  if [[ $1 = -* ]] ; then
    while [[ -n $@ ]] && [[ $1 != -- ]] ; do 
      opts+="$1"
      shift
    done
    shift
  fi

  evaluate-command $1 # result is returned in $reply  
  if [[ $? != 0 ]] ; then
    echo "$1 not found"
    return 1
  fi
  shift
  set -A args "\"$@\""
#  set -A command $reply "\"$@\"" # add *quoted* args
#  set -A expandedCommand $reply $~args # expansion on an array
  set -A expandedCommand $reply $args
  unset reply
#  set -A expandedCommand $~command # expansion on an array

  local -a ksuArgs
  ksuArgs=("-q" "-e")

  if [[ $OSTYPE != *bsd* ]] && grep -q krb /etc/pam.d/common-auth && klist -5 -s ADN ; then
# && ksu $ksuArgs /bin/true ADN ; then
    ksu $ksuArgs $SHELL -c "$expandedCommand"
  else
    sudo $opts $SHELL -c "$expandedCommand"
  fi
}

se() {
  service=$1
  shift
  s /etc/init.d/$service $@
}

setcpufreq() {
  local f=${1}Ghz
  s cpufreq-set -f $f
  s cpufreq-set -c 1 -f $f
}

setlocale() {
  local locale=$1
  if locale -a | grep -q $locale ; then
    export LANG=$locale
    export LC_ALL=$locale
  else
    echo "$locale is not a valid locale. Try locale -a for available locales."
  fi
}

ssh-authorize-key() {
  [[ ${#argv} -lt 1 ]] && echo "$0 <host> [key>]" && return 1
  if [[ -z "$2" ]] ; then
    [[ -f ~/.ssh/new-mv.rsa.pub ]] && pubKey=~/.ssh/new-mv.rsa.pub || pubKey=~/.ssh/home.rsa.pub
  else
    pubKey=$2
  fi
  cat $pubKey | ssh $1 "(mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/authorized_keys)"
}

ssh-remove-key() {
#  setopt localoptions xtrace
  ssh -o StrictHostKeyChecking=yes $1 echo |& awk '/^Offending key/ { gsub(/.*:/, "") ; print }' | while read line ; do
    perl -i -pe 's/^.*\n// if ($. == '"$line"')' ~/.ssh/known_hosts
  done
}

xpop() {
  set -A commandAndArgs ${=1} # split $1 as if SH_WORD_SPLIT was set
  shift

  local c=$commandAndArgs[1]
  shift 1 commandAndArgs

  evaluate-command $c # result is returned in $reply
  if [[ $? != 0 ]] ; then
    echo "$c not found"
    return 1
  fi
  set -A command $reply "$commandAndArgs[@]" # add args
  set -A expandedCommand $~command # nice trick to do expansion on an array
  unset reply

  local name=$1
  shift

  if [ -n "${DISPLAY}" ] ; then
    ${=XTERM/&/} $@ -T "$name" -e zsh -c "$expandedCommand" &
  else
    zsh -c "$expandedCommand"
  fi
}

zbootstrap() {
  [[ ! ${#argv} -eq 1 ]] && echo "$0 <host>" && return 1
  scp -r .screenrc $ZSH_CONFIG_FILES $1:
}
