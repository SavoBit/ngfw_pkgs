diff -Naur linux-2.6.16.12/include/linux/in.h linux-2.6.16.12-patched/include/linux/in.h
--- linux-2.6.16.12/include/linux/in.h	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/include/linux/in.h	2007-03-19 21:00:33.000000000 -0700
@@ -76,6 +76,13 @@
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
 
+/* Extensions */
+#define IP_SADDR	20
+#define IP_RECVNFMARK	22
+#define IP_SENDNFMARK	23
+#define IP_FIRSTNFMARK	24
+#define IP_FIRSTSEQ	25
+
 /* IP_MTU_DISCOVER values */
 #define IP_PMTUDISC_DONT		0	/* Never send DF frames */
 #define IP_PMTUDISC_WANT		1	/* Use per route hints	*/
@@ -185,6 +192,15 @@
 };
 #define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
 
+struct ip_firstseq_opts {
+    u_int32_t rcv_nxt;
+    u_int32_t snd_nxt;
+};
+
+struct ip_sendnfmark_opts {
+    u_int32_t on;
+    u_int32_t mark;
+};
 
 /*
  * Definitions of the bits in an Internet address integer.
diff -Naur linux-2.6.16.12/include/linux/udp.h linux-2.6.16.12-patched/include/linux/udp.h
--- linux-2.6.16.12/include/linux/udp.h	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/include/linux/udp.h	2007-03-19 21:00:33.000000000 -0700
@@ -30,6 +30,15 @@
 #define UDP_CORK	1	/* Never send partially complete segments */
 #define UDP_ENCAP	100	/* Set the socket to accept encapsulated packets */
 
+/* Extensions */
+#define UDP_RECVHDR 2   /* the original ip and udp hdr in ancillary msg */
+
+/* UDP cmsg options */
+#define UDP_CMSG_RECVHDR     32 /* see udp.c, ip_sockglue.c */
+
+/* UDP ancillary data types */
+#define UDP_SPORT 1
+
 /* UDP encapsulation types */
 #define UDP_ENCAP_ESPINUDP_NON_IKE	1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
 #define UDP_ENCAP_ESPINUDP	2 /* draft-ietf-ipsec-udp-encaps-06 */
diff -Naur linux-2.6.16.12/include/net/ip.h linux-2.6.16.12-patched/include/net/ip.h
--- linux-2.6.16.12/include/net/ip.h	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/include/net/ip.h	2007-03-19 21:00:33.000000000 -0700
@@ -37,6 +37,10 @@
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
 
+    /* Extensions */
+    unsigned char    pkt_ip_ttl;
+    unsigned char    pkt_ip_tos;
+
 #define IPSKB_FORWARDED		1
 #define IPSKB_XFRM_TUNNEL_SIZE	2
 #define IPSKB_XFRM_TRANSFORMED	4
@@ -49,6 +53,12 @@
 	u32			addr;
 	int			oif;
 	struct ip_options	*opt;
+
+    /* Extensions */
+    u8 pkt_ip_ttl;
+    u8 pkt_ip_tos;
+    u16 pkt_udp_sport;
+    u32 nfmark;
 };
 
 #define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
diff -Naur linux-2.6.16.12/include/net/sock.h linux-2.6.16.12-patched/include/net/sock.h
--- linux-2.6.16.12/include/net/sock.h	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/include/net/sock.h	2007-03-19 21:00:33.000000000 -0700
@@ -212,6 +212,14 @@
 	int			sk_route_caps;
 	unsigned long 		sk_flags;
 	unsigned long	        sk_lingertime;
+
+    /* Extensions */
+ 	unsigned long	        sk_nfmarkopts;
+ 	unsigned long	        sk_nfmark;
+ 	unsigned long	        sk_sendnfmark;
+ 	unsigned long	        sk_snd_first;
+ 	unsigned long	        sk_rcv_first;
+    
 	/*
 	 * The backlog queue is special, it is always used with
 	 * the per-socket spinlock held and requires low latency
diff -Naur linux-2.6.16.12/net/ipv4/icmp.c linux-2.6.16.12-patched/net/ipv4/icmp.c
--- linux-2.6.16.12/net/ipv4/icmp.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/icmp.c	2007-03-19 21:22:44.000000000 -0700
@@ -390,6 +390,8 @@
 	if (icmp_xmit_lock())
 		return;
 
+	memset(&ipc, 0, sizeof(ipc));
+
 	icmp_param->data.icmph.checksum = 0;
 	icmp_out_count(icmp_param->data.icmph.type);
 
@@ -539,6 +541,7 @@
 	icmp_param.offset = skb_in->nh.raw - skb_in->data;
 	icmp_out_count(icmp_param.data.icmph.type);
 	inet_sk(icmp_socket->sk)->tos = tos;
+	memset(&ipc, 0, sizeof(ipc));
 	ipc.addr = iph->saddr;
 	ipc.opt = &icmp_param.replyopts;
 
diff -Naur linux-2.6.16.12/net/ipv4/ip_output.c linux-2.6.16.12-patched/net/ipv4/ip_output.c
--- linux-2.6.16.12/net/ipv4/ip_output.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/ip_output.c	2007-03-19 21:26:25.000000000 -0700
@@ -154,6 +154,9 @@
 
 	skb->priority = sk->sk_priority;
 
+	if (sk->sk_nfmarkopts & 0x00000001)
+		skb->nfmark = sk->sk_sendnfmark;
+
 	/* Send it out. */
 	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
 		       dst_output);
@@ -939,6 +942,17 @@
 			data += fragheaderlen;
 			skb->h.raw = data + exthdrlen;
 
+            if (ipc->pkt_ip_ttl)
+                IPCB(skb)->pkt_ip_ttl = ipc->pkt_ip_ttl;
+            else 
+                IPCB(skb)->pkt_ip_ttl = 0;
+            if (ipc->pkt_ip_tos)
+                IPCB(skb)->pkt_ip_tos = ipc->pkt_ip_tos;
+            else 
+                IPCB(skb)->pkt_ip_tos = 0;
+
+            skb->nfmark = ipc->nfmark;
+            
 			if (fraggap) {
 				skb->csum = skb_copy_and_csum_bits(
 					skb_prev, maxfraglen,
@@ -1247,10 +1261,18 @@
 		ip_options_build(skb, opt, inet->cork.addr, rt, 0);
 	}
 	iph->tos = inet->tos;
+
+    if (IPCB(skb)->pkt_ip_tos) 
+        iph->tos = IPCB(skb)->pkt_ip_tos;
+
 	iph->tot_len = htons(skb->len);
 	iph->frag_off = df;
 	ip_select_ident(iph, &rt->u.dst, sk);
 	iph->ttl = ttl;
+
+    if (IPCB(skb)->pkt_ip_ttl) 
+        iph->ttl = IPCB(skb)->pkt_ip_ttl;
+
 	iph->protocol = sk->sk_protocol;
 	iph->saddr = rt->rt_src;
 	iph->daddr = rt->rt_dst;
@@ -1343,6 +1365,7 @@
 		return;
 
 	daddr = ipc.addr = rt->rt_src;
+	memset(&ipc, 0, sizeof(ipc));
 	ipc.opt = NULL;
 
 	if (replyopts.opt.optlen) {
diff -Naur linux-2.6.16.12/net/ipv4/ip_sockglue.c linux-2.6.16.12-patched/net/ipv4/ip_sockglue.c
--- linux-2.6.16.12/net/ipv4/ip_sockglue.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/ip_sockglue.c	2007-03-19 21:00:33.000000000 -0700
@@ -50,6 +50,8 @@
 #define IP_CMSG_TOS		4
 #define IP_CMSG_RECVOPTS	8
 #define IP_CMSG_RETOPTS		16
+/* 32 is udp_cmsg_recvhdr */
+#define IP_CMSG_NFMARK		64 
 
 /*
  *	SOL_IP control messages.
@@ -72,6 +74,12 @@
 	put_cmsg(msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);
 }
 
+static void ip_cmsg_recv_nfmark(struct msghdr *msg, struct sk_buff *skb)
+{
+	unsigned int nfmark = skb->nfmark;
+	put_cmsg(msg, SOL_IP, IP_RECVNFMARK, sizeof(unsigned int), &nfmark);
+}
+
 static void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)
 {
 	int ttl = skb->nh.iph->ttl;
@@ -138,6 +146,17 @@
 
 	if (flags & 1)
 		ip_cmsg_recv_retopts(msg, skb);
+	if ((flags>>=1) == 0)
+		return;
+
+	/* ignore UDP_CMSG_RECVHDR */
+	if ((flags>>=1) == 0)
+		return;
+
+	if (flags & 1) /* IP_CMSG_NFMARK */
+		ip_cmsg_recv_nfmark(msg, skb);
+	if ((flags>>=1) == 0)
+		return;
 }
 
 int ip_cmsg_send(struct msghdr *msg, struct ipcm_cookie *ipc)
@@ -167,7 +186,38 @@
 			ipc->addr = info->ipi_spec_dst.s_addr;
 			break;
 		}
+        case IP_SADDR:
+        {
+            struct in_addr *in;
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_addr))) 
+                return -EINVAL;
+            in = (struct in_addr *)CMSG_DATA(cmsg);
+            ipc->addr = in->s_addr;
+            break;
+        }
+        case IP_TTL:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_ttl = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+        case IP_TOS:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_tos = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+       case IP_SENDNFMARK:
+       {
+           if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned long))) 
+               return -EINVAL;
+           ipc->nfmark = *(unsigned long *)CMSG_DATA(cmsg);
+           break;
+       }
 		default:
+            printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
 			return -EINVAL;
 		}
 	}
@@ -390,6 +440,7 @@
 
 	if (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) | 
 			    (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) | 
+			    (1<<IP_RECVNFMARK) |
 			    (1<<IP_RETOPTS) | (1<<IP_TOS) | 
 			    (1<<IP_TTL) | (1<<IP_HDRINCL) | 
 			    (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) | 
@@ -454,6 +505,32 @@
 			else
 				inet->cmsg_flags &= ~IP_CMSG_PKTINFO;
 			break;
+        case IP_RECVNFMARK:
+            if (val)
+                inet->cmsg_flags |=  IP_CMSG_NFMARK;
+            else
+                inet->cmsg_flags &= ~IP_CMSG_NFMARK;
+             break;
+        case IP_SENDNFMARK:
+        {
+            struct ip_sendnfmark_opts nfopt;
+
+            if (optlen != sizeof(struct ip_sendnfmark_opts))
+                goto e_inval;
+            if (copy_from_user(&nfopt, optval, sizeof(struct ip_sendnfmark_opts))) {
+                err = -EFAULT;
+                break;
+            }
+
+            if (nfopt.on) {
+                sk->sk_sendnfmark = nfopt.mark;
+                sk->sk_nfmarkopts |=  0x00000001;
+            }
+            else {
+                sk->sk_nfmarkopts &= ~0x00000001;
+            }
+            break;
+        }
 		case IP_RECVTTL:
 			if (val)
 				inet->cmsg_flags |=  IP_CMSG_TTL;
@@ -917,6 +994,44 @@
 					return -EFAULT;
 				return 0;
 			}
+		case IP_SENDNFMARK:
+        {
+            struct ip_sendnfmark_opts opts;
+
+            if (sk->sk_nfmarkopts & 0x00000001) 
+                opts.on = 1;
+	    else
+                opts.on = 0;
+            opts.mark =  sk->sk_sendnfmark;
+	    release_sock(sk);
+            
+			if (len < sizeof(struct ip_sendnfmark_opts)) {
+				return -EINVAL;
+			}
+			if(copy_to_user(optval, &opts, sizeof(struct ip_sendnfmark_opts))) {
+				return -EFAULT;
+			}
+            return 0;
+        }
+		case IP_FIRSTSEQ:
+        {
+            struct ip_firstseq_opts opts;
+
+            opts.rcv_nxt = sk->sk_rcv_first;
+            opts.snd_nxt = sk->sk_snd_first;
+	    release_sock(sk);
+            
+			if (len < sizeof(struct ip_firstseq_opts)) {
+				return -EINVAL;
+			}
+			if(copy_to_user(optval, &opts, sizeof(struct ip_firstseq_opts))) {
+				return -EFAULT;
+			}
+            return 0;
+        }
+		case IP_FIRSTNFMARK:
+			val = sk->sk_nfmark;
+			break;
 		case IP_PKTINFO:
 			val = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;
 			break;
diff -Naur linux-2.6.16.12/net/ipv4/raw.c linux-2.6.16.12-patched/net/ipv4/raw.c
--- linux-2.6.16.12/net/ipv4/raw.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/raw.c	2007-03-19 21:18:57.000000000 -0700
@@ -430,6 +430,8 @@
 		daddr = inet->daddr;
 	}
 
+	memset(&ipc, 0, sizeof(ipc));
+
 	ipc.addr = inet->saddr;
 	ipc.opt = NULL;
 	ipc.oif = sk->sk_bound_dev_if;
diff -Naur linux-2.6.16.12/net/ipv4/tcp_input.c linux-2.6.16.12-patched/net/ipv4/tcp_input.c
--- linux-2.6.16.12/net/ipv4/tcp_input.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/tcp_input.c	2007-03-19 21:00:33.000000000 -0700
@@ -4076,6 +4076,8 @@
 		 */
 		tp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;
 		tp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;
+		sk->sk_rcv_first = tp->rcv_nxt;
+		sk->sk_snd_first = tp->snd_nxt;
 
 		/* RFC1323: The window in SYN & SYN/ACK segments is
 		 * never scaled.
diff -Naur linux-2.6.16.12/net/ipv4/tcp_ipv4.c linux-2.6.16.12-patched/net/ipv4/tcp_ipv4.c
--- linux-2.6.16.12/net/ipv4/tcp_ipv4.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/tcp_ipv4.c	2007-03-19 21:00:33.000000000 -0700
@@ -883,6 +883,8 @@
 	if (!newsk)
 		goto exit;
 
+	newsk->sk_nfmark = skb->nfmark;
+
 	sk_setup_caps(newsk, dst);
 
 	newtp		      = tcp_sk(newsk);
diff -Naur linux-2.6.16.12/net/ipv4/tcp_minisocks.c linux-2.6.16.12-patched/net/ipv4/tcp_minisocks.c
--- linux-2.6.16.12/net/ipv4/tcp_minisocks.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/tcp_minisocks.c	2007-03-19 21:00:33.000000000 -0700
@@ -359,6 +359,8 @@
 		newtp->pred_flags = 0;
 		newtp->rcv_nxt = treq->rcv_isn + 1;
 		newtp->snd_nxt = newtp->snd_una = newtp->snd_sml = treq->snt_isn + 1;
+		newsk->sk_rcv_first = newtp->rcv_nxt;
+		newsk->sk_snd_first = newtp->snd_nxt;
 
 		tcp_prequeue_init(newtp);
 
diff -Naur linux-2.6.16.12/net/ipv4/tcp_output.c linux-2.6.16.12-patched/net/ipv4/tcp_output.c
--- linux-2.6.16.12/net/ipv4/tcp_output.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/tcp_output.c	2007-03-19 21:00:34.000000000 -0700
@@ -448,6 +448,9 @@
 	if (skb->len != tcp_header_size)
 		tcp_event_data_sent(tp, skb, sk);
 
+        if (sk->sk_nfmarkopts & 0x00000001)
+            skb->nfmark = sk->sk_sendnfmark;
+
 	TCP_INC_STATS(TCP_MIB_OUTSEGS);
 
 	err = icsk->icsk_af_ops->queue_xmit(skb, 0);
diff -Naur linux-2.6.16.12/net/ipv4/udp.c linux-2.6.16.12-patched/net/ipv4/udp.c
--- linux-2.6.16.12/net/ipv4/udp.c	2006-05-01 12:14:26.000000000 -0700
+++ linux-2.6.16.12-patched/net/ipv4/udp.c	2007-03-19 21:13:25.000000000 -0700
@@ -110,6 +110,26 @@
 #include <net/checksum.h>
 #include <net/xfrm.h>
 
+static void udp_cmsg_recv_hdr(struct msghdr *msg, struct sk_buff *skb)
+{
+    int size = ((skb->nh.iph->ihl) * 4) + sizeof (struct udphdr);
+
+    /* FIXME check for room */
+
+    put_cmsg(msg, SOL_UDP, UDP_RECVHDR, size, skb->nh.iph);
+}
+
+void udp_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
+{
+	struct inet_sock *inet = inet_sk(skb->sk);
+	unsigned flags = inet->cmsg_flags;
+    
+    if (flags & UDP_CMSG_RECVHDR)
+        udp_cmsg_recv_hdr(msg, skb);
+
+    ip_cmsg_recv(msg, skb);
+}
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -218,6 +238,32 @@
 	write_unlock_bh(&udp_hash_lock);
 }
 
+static int udp_cmsg_send(struct msghdr *msg, struct ipcm_cookie *ipc)
+{
+    struct cmsghdr *cmsg;
+ 
+    for (cmsg = CMSG_FIRSTHDR(msg); cmsg;
+         cmsg = CMSG_NXTHDR(msg, cmsg)) {
+ 
+        if (cmsg->cmsg_level == SOL_UDP) {
+            switch (cmsg->cmsg_type) {
+ 
+            case UDP_SPORT:
+                if (cmsg->cmsg_len != CMSG_LEN(sizeof(u_short)))
+                    return -EINVAL;
+                ipc->pkt_udp_sport = *(u_short*)CMSG_DATA(cmsg);
+                break;
+                 
+            default:
+                printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
+                return -EINVAL;
+            }
+        }
+    }
+ 
+    return ip_cmsg_send(msg,ipc);
+}
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -492,7 +538,7 @@
 	int free = 0;
 	int connected = 0;
 	u32 daddr, faddr, saddr;
-	u16 dport;
+	u16 dport, sport;
 	u8  tos;
 	int err;
 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
@@ -507,6 +553,7 @@
 	if (msg->msg_flags&MSG_OOB)	/* Mirror BSD error message compatibility */
 		return -EOPNOTSUPP;
 
+	memset(&ipc, 0, sizeof(ipc));
 	ipc.opt = NULL;
 
 	if (up->pending) {
@@ -556,7 +603,8 @@
 
 	ipc.oif = sk->sk_bound_dev_if;
 	if (msg->msg_controllen) {
-		err = ip_cmsg_send(msg, &ipc);
+        err = udp_cmsg_send(msg, &ipc); /* also calls ip_cmsg_send */
+
 		if (err)
 			return err;
 		if (ipc.opt)
@@ -566,6 +614,11 @@
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
 
+    sport = inet->sport;
+
+    if (ipc.pkt_udp_sport)
+        sport = ipc.pkt_udp_sport;
+
 	saddr = ipc.addr;
 	ipc.addr = faddr = daddr;
 
@@ -576,6 +629,10 @@
 		connected = 0;
 	}
 	tos = RT_TOS(inet->tos);
+
+    if (ipc.pkt_udp_sport || ipc.addr)
+        tos |= RTO_TPROXY;
+
 	if (sock_flag(sk, SOCK_LOCALROUTE) ||
 	    (msg->msg_flags & MSG_DONTROUTE) || 
 	    (ipc.opt && ipc.opt->is_strictroute)) {
@@ -602,7 +659,7 @@
 						.tos = tos } },
 				    .proto = IPPROTO_UDP,
 				    .uli_u = { .ports =
-					       { .sport = inet->sport,
+					       { .sport = sport,
 						 .dport = dport } } };
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
@@ -640,7 +697,7 @@
 	inet->cork.fl.fl4_dst = daddr;
 	inet->cork.fl.fl_ip_dport = dport;
 	inet->cork.fl.fl4_src = saddr;
-	inet->cork.fl.fl_ip_sport = inet->sport;
+	inet->cork.fl.fl_ip_sport = sport;
 	up->pending = AF_INET;
 
 do_append_data:
@@ -795,6 +852,7 @@
 
 try_again:
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
+
 	if (!skb)
 		goto out;
   
@@ -832,8 +890,9 @@
 		sin->sin_addr.s_addr = skb->nh.iph->saddr;
 		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
   	}
-	if (inet->cmsg_flags)
-		ip_cmsg_recv(msg, skb);
+	if (inet->cmsg_flags) {
+        udp_cmsg_recv(msg, skb); /* also calls ip_cmsg_recv */
+    }
 
 	err = copied;
 	if (flags & MSG_TRUNC)
@@ -1235,6 +1294,13 @@
 		}
 		break;
 		
+    case UDP_RECVHDR: 
+        if (val)
+            inet_sk(sk)->cmsg_flags |= UDP_CMSG_RECVHDR;
+        else
+            inet_sk(sk)->cmsg_flags &= ~UDP_CMSG_RECVHDR;
+        break;
+
 	case UDP_ENCAP:
 		switch (val) {
 		case 0:
@@ -1278,6 +1344,10 @@
 		val = up->corkflag;
 		break;
 
+    case UDP_RECVHDR:
+        val = ((inet_sk(sk)->cmsg_flags & UDP_CMSG_RECVHDR) != 0);
+        break;
+
 	case UDP_ENCAP:
 		val = up->encap_type;
 		break;
