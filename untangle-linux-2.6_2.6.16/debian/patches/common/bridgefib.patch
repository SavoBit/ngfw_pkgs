diff -Nru linux-2.6.14.2-orig/include/linux/if_bridge.h linux-2.6.14.2-mv/include/linux/if_bridge.h
--- linux-2.6.14.2-orig/include/linux/if_bridge.h	2005-11-10 21:33:12.000000000 -0800
+++ linux-2.6.14.2-mv/include/linux/if_bridge.h	2005-11-14 12:07:36.489447133 -0800
@@ -44,6 +44,7 @@
 #define BRCTL_SET_PORT_PRIORITY 16
 #define BRCTL_SET_PATH_COST 17
 #define BRCTL_GET_FDB_ENTRIES 18
+#define BRCTL_GET_DEVNAME 19
 
 #define BR_STATE_DISABLED 0
 #define BR_STATE_LISTENING 1
diff -Nru linux-2.6.14.2-orig/include/linux/sockios.h linux-2.6.14.2-mv/include/linux/sockios.h
--- linux-2.6.14.2-orig/include/linux/sockios.h	2005-11-10 21:33:12.000000000 -0800
+++ linux-2.6.14.2-mv/include/linux/sockios.h	2005-11-14 12:07:36.490447054 -0800
@@ -28,6 +28,7 @@
 #define SIOCADDRT	0x890B		/* add routing table entry	*/
 #define SIOCDELRT	0x890C		/* delete routing table entry	*/
 #define SIOCRTMSG	0x890D		/* call to routing system	*/
+#define SIOCFINDEV	0x890E		/* call to find output dev	*/
 
 /* Socket configuration controls. */
 #define SIOCGIFNAME	0x8910		/* get iface name		*/
diff -Nru linux-2.6.14.2-orig/net/bridge/br_ioctl.c linux-2.6.14.2-mv/net/bridge/br_ioctl.c
--- linux-2.6.14.2-orig/net/bridge/br_ioctl.c	2005-11-10 21:33:12.000000000 -0800
+++ linux-2.6.14.2-mv/net/bridge/br_ioctl.c	2005-11-14 12:07:36.490447054 -0800
@@ -248,6 +248,33 @@
 		return 0;
 	}
 
+ 	case BRCTL_GET_DEVNAME:
+ 	{
+ 		struct net_device *dev;
+ 		struct net_bridge *br;
+ 		unsigned char dest[ETH_HLEN];
+ 		char brname[IFNAMSIZ];
+ 		struct net_bridge_fdb_entry *dst;
+ 
+ 		copy_from_user(dest, (void __user *)args[2], ETH_HLEN);
+ 		copy_from_user(brname, (void __user *)args[1], IFNAMSIZ);
+ 		dev = __dev_get_by_name(brname);
+ 		br = netdev_priv(dev);
+ 
+ 		rcu_read_lock();
+                 dst = __br_fdb_get(br, dest);
+                 
+ 		if (dst != NULL) {
+                         memcpy(brname, dst->dst->dev->name, IFNAMSIZ);
+                         rcu_read_unlock();
+ 			copy_to_user((void __user *)args[1], brname, IFNAMSIZ);
+                         return dst->dst->dev->ifindex;
+ 		} else {
+                         rcu_read_unlock();
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
 	case BRCTL_SET_BRIDGE_STP_STATE:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
diff -Nru linux-2.6.14.2-orig/net/ipv4/af_inet.c linux-2.6.14.2-mv/net/ipv4/af_inet.c
--- linux-2.6.14.2-orig/net/ipv4/af_inet.c	2005-11-10 21:33:12.000000000 -0800
+++ linux-2.6.14.2-mv/net/ipv4/af_inet.c	2005-11-14 12:07:36.491446976 -0800
@@ -754,6 +754,7 @@
 		case SIOCGSTAMP:
 			err = sock_get_timestamp(sk, (struct timeval __user *)arg);
 			break;
+		case SIOCFINDEV:
 		case SIOCADDRT:
 		case SIOCDELRT:
 		case SIOCRTMSG:
diff -Nru linux-2.6.14.2-orig/net/ipv4/fib_frontend.c linux-2.6.14.2-mv/net/ipv4/fib_frontend.c
--- linux-2.6.14.2-orig/net/ipv4/fib_frontend.c	2005-11-10 21:33:12.000000000 -0800
+++ linux-2.6.14.2-mv/net/ipv4/fib_frontend.c	2005-11-14 12:07:36.492446897 -0800
@@ -233,10 +233,49 @@
 
 #ifndef CONFIG_IP_NOSIOCRT
 
+static int findev(unsigned int remote, char *p, u32 *nh_gw)
+{
+	struct flowi fl = { .nl_u = { .ip4_u =
+				      { .daddr = remote,
+					.saddr = 0,
+					.tos = 0,
+//					.scope = ((tos & RTO_ONLINK) ?
+					.scope = ((0 & RTO_ONLINK) ?
+						  RT_SCOPE_LINK :
+						  RT_SCOPE_UNIVERSE),
+#ifdef CONFIG_IP_ROUTE_FWMARK
+					.fwmark = 0
+#endif
+				      } },
+			    .iif = loopback_dev.ifindex,
+			    .oif = 0 };
+	struct fib_result res;
+	struct net_device *dev_out = NULL;
+
+	res.fi		= NULL;
+#ifdef CONFIG_IP_MULTIPLE_TABLES
+	res.r		= NULL;
+#endif
+	if (fib_lookup(&fl, &res)) {
+			return 0;
+	}
+	*nh_gw = FIB_RES_GW(res);
+	if (res.type == RTN_LOCAL) {
+		dev_out = &loopback_dev;
+	} else {
+		dev_out = FIB_RES_DEV(res);
+	}
+	dev_hold(dev_out);
+	fib_res_put(&res);
+	strcpy(p, dev_out->name);
+       fl.oif = dev_out->ifindex;
+	dev_put(dev_out);
+	return fl.oif;
+}
+
 /*
  *	Handle IP routing ioctl calls. These are used to manipulate the routing tables
  */
- 
 int ip_rt_ioctl(unsigned int cmd, void __user *arg)
 {
 	int err;
@@ -246,8 +285,23 @@
 		struct nlmsghdr nlh;
 		struct rtmsg	rtm;
 	} req;
+	struct {
+		u32 addr;
+		u32 nh;
+		char name[IFNAMSIZ];
+	} nh_req;
 
 	switch (cmd) {
+	case SIOCFINDEV:
+		if (copy_from_user(&nh_req, arg, sizeof(nh_req))) {
+			return -EFAULT;
+		} else {
+			int oif = findev(nh_req.addr, nh_req.name, &nh_req.nh);
+			if (oif == 0)
+				return -ENETUNREACH;
+			copy_to_user(arg, &nh_req, sizeof(nh_req));
+			return(oif);
+		}
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
 		if (!capable(CAP_NET_ADMIN))
