Binary files linux-2.6.16.12/.icmp_frag.kernel-2.6.14.3.patch.swp and bar/.icmp_frag.kernel-2.6.14.3.patch.swp differ
diff -rNu linux-2.6.16.12/include/linux/in.h bar/include/linux/in.h
--- linux-2.6.16.12/include/linux/in.h	2006-05-01 12:14:26.000000000 -0700
+++ bar/include/linux/in.h	2006-05-01 17:23:42.757469596 -0700
@@ -72,6 +72,7 @@
 #define IP_FREEBIND	15
 #define IP_IPSEC_POLICY	16
 #define IP_XFRM_POLICY	17
+#define IP_NONLOCAL	18
 
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
Binary files linux-2.6.16.12/include/net/.ip.h.swp and bar/include/net/.ip.h.swp differ
diff -rNu linux-2.6.16.12/include/net/ip.h bar/include/net/ip.h
--- linux-2.6.16.12/include/net/ip.h	2006-05-01 16:12:46.618821909 -0700
+++ bar/include/net/ip.h	2006-05-01 17:23:42.758469526 -0700
@@ -321,6 +321,7 @@
 	IP_DEFRAG_CALL_RA_CHAIN,
 	IP_DEFRAG_CONNTRACK_IN,
 	IP_DEFRAG_CONNTRACK_OUT,
+	IP_DEFRAG_NONLOCAL,
 	IP_DEFRAG_VS_IN,
 	IP_DEFRAG_VS_OUT,
 	IP_DEFRAG_VS_FWD
diff -rNu linux-2.6.16.12/include/net/route.h bar/include/net/route.h
--- linux-2.6.16.12/include/net/route.h	2006-05-01 12:14:26.000000000 -0700
+++ bar/include/net/route.h	2006-05-01 17:23:42.758469526 -0700
@@ -39,12 +39,19 @@
 #endif
 
 #define RTO_ONLINK	0x01
+#define RTO_TPROXY   0x02	
 
 #define RTO_CONN	0
 /* RTO_CONN is not used (being alias for 0), but preserved not to break
  * some modules referring to it. */
 
-#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
+#ifdef CONFIG_IP_NF_NONLOCAL
+#define RTO_SCONN(sk) ((sk)->sk_reuse > 1 ? RTO_TPROXY : 0)
+#else
+#define RTO_SCONN(sk) 0
+#endif
+ 
+#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE) | RTO_SCONN(sk))
 
 struct fib_nh;
 struct inet_peer;
diff -rNu linux-2.6.16.12/include/net/tcp.h bar/include/net/tcp.h
--- linux-2.6.16.12/include/net/tcp.h	2006-05-01 12:14:26.000000000 -0700
+++ bar/include/net/tcp.h	2006-05-01 17:23:42.769468755 -0700
@@ -263,6 +263,8 @@
 
 extern int			tcp_v4_rcv(struct sk_buff *skb);
 
+extern struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb);
+    
 extern int			tcp_v4_remember_stamp(struct sock *sk);
 
 extern int		    	tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
Binary files linux-2.6.16.12/net/ipv4/.ip_output.c.swp and bar/net/ipv4/.ip_output.c.swp differ
Binary files linux-2.6.16.12/net/ipv4/.tcp_output.c.swp and bar/net/ipv4/.tcp_output.c.swp differ
diff -rNu linux-2.6.16.12/net/ipv4/ip_sockglue.c bar/net/ipv4/ip_sockglue.c
--- linux-2.6.16.12/net/ipv4/ip_sockglue.c	2006-05-01 12:14:26.000000000 -0700
+++ bar/net/ipv4/ip_sockglue.c	2006-05-01 17:23:42.770468685 -0700
@@ -393,7 +393,7 @@
 			    (1<<IP_RETOPTS) | (1<<IP_TOS) | 
 			    (1<<IP_TTL) | (1<<IP_HDRINCL) | 
 			    (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) | 
-			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND))) || 
+			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) | (1<<IP_NONLOCAL))) || 
 				optname == IP_MULTICAST_TTL || 
 				optname == IP_MULTICAST_LOOP) { 
 		if (optlen >= sizeof(int)) {
@@ -518,6 +518,16 @@
 			if (!val)
 				skb_queue_purge(&sk->sk_error_queue);
 			break;
+		case IP_NONLOCAL:
+            if (optlen<1)
+                goto e_inval;
+            /* if (!capable(CAP_NET_ADMIN)) */
+            /*    goto e_inval;             */
+            if (val)
+                sk->sk_reuse = 2;
+            else if (sk->sk_reuse == 2)
+                sk->sk_reuse = 1;
+            break;
 		case IP_MULTICAST_TTL:
 			if (sk->sk_type == SOCK_STREAM)
 				goto e_inval;
diff -rNu linux-2.6.16.12/net/ipv4/netfilter/Kconfig bar/net/ipv4/netfilter/Kconfig
--- linux-2.6.16.12/net/ipv4/netfilter/Kconfig	2006-05-01 17:20:18.638258296 -0700
+++ bar/net/ipv4/netfilter/Kconfig	2006-05-01 17:23:42.771468615 -0700
@@ -27,7 +27,13 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
-# connection tracking, helpers and protocols
+config IP_NF_NONLOCAL
+	tristate "Nonlocal Binding Support"
+	---help---
+	  Nonlocal Binding support
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_CONNTRACK
 	tristate "Connection tracking (required for masq/NAT)"
 	---help---
diff -rNu linux-2.6.16.12/net/ipv4/netfilter/Makefile bar/net/ipv4/netfilter/Makefile
--- linux-2.6.16.12/net/ipv4/netfilter/Makefile	2006-05-01 17:20:18.639258241 -0700
+++ bar/net/ipv4/netfilter/Makefile	2006-05-01 17:23:42.771468615 -0700
@@ -24,6 +24,9 @@
 # SCTP protocol connection tracking
 obj-$(CONFIG_IP_NF_CT_PROTO_SCTP) += ip_conntrack_proto_sctp.o
 
+# non-local support
+obj-$(CONFIG_IP_NF_NONLOCAL) += ip_nonlocal.o
+
 # connection tracking helpers
 obj-$(CONFIG_IP_NF_PPTP) += ip_conntrack_pptp.o
 obj-$(CONFIG_IP_NF_AMANDA) += ip_conntrack_amanda.o
diff -rNu linux-2.6.16.12/net/ipv4/netfilter/ip_nonlocal.c bar/net/ipv4/netfilter/ip_nonlocal.c
--- linux-2.6.16.12/net/ipv4/netfilter/ip_nonlocal.c	1969-12-31 16:00:00.000000000 -0800
+++ bar/net/ipv4/netfilter/ip_nonlocal.c	2006-05-01 17:23:42.771468615 -0700
@@ -0,0 +1,72 @@
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <net/checksum.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Original Author Unknown");
+MODULE_DESCRIPTION("Nonlocal binding hook");
+
+static unsigned int ip_nonlocal_in(unsigned int hooknum,
+                                    struct sk_buff **pskb,
+                                    const struct net_device *in,
+                                    const struct net_device *out,
+                                    int (*okfn)(struct sk_buff *))
+{
+    struct sk_buff* skb = *pskb;
+    if (skb->nh.iph->protocol == IPPROTO_TCP || skb->nh.iph->protocol == IPPROTO_ICMP) {           
+        if ((skb = tcp_v4_nonlocal_deliver(skb)) == NULL) 
+            return NF_STOLEN;                        
+    }                                                     
+
+    return NF_ACCEPT;
+}
+
+static struct nf_hook_ops ip_nonlocal_forward_ops = {
+	.hook		= ip_nonlocal_in,
+	.pf  		= PF_INET,
+	.hooknum	= NF_IP_PRE_ROUTING,
+	.priority	= NF_IP_PRI_FIRST+1,
+};
+
+static int init_or_cleanup(int init)
+{
+	int ret = 0;
+
+	if (!init) 
+        goto cleanup;
+
+	ret = nf_register_hook(&ip_nonlocal_forward_ops);
+	if (ret < 0) {
+		printk("ip_nonlocal: can't register pre-routing hook.\n");
+		goto cleanup;
+	}
+
+	return ret;
+
+ cleanup:
+	nf_unregister_hook(&ip_nonlocal_forward_ops);
+	return ret;
+}
+
+static int __init init(void)
+{
+	return init_or_cleanup(1);
+}
+
+static void __exit fini(void)
+{
+	init_or_cleanup(0);
+}
+
+module_init(init);
+module_exit(fini);
+
+
diff -rNu linux-2.6.16.12/net/ipv4/raw.c bar/net/ipv4/raw.c
--- linux-2.6.16.12/net/ipv4/raw.c	2006-05-01 12:14:26.000000000 -0700
+++ bar/net/ipv4/raw.c	2006-05-01 17:23:42.772468544 -0700
@@ -464,6 +464,9 @@
 	tos = RT_CONN_FLAGS(sk);
 	if (msg->msg_flags & MSG_DONTROUTE)
 		tos |= RTO_ONLINK;
+#ifdef CONFIG_IP_NF_NONLOCAL
+        tos |= saddr ? RTO_TPROXY : 0;
+#endif
 
 	if (MULTICAST(daddr)) {
 		if (!ipc.oif)
diff -rNu linux-2.6.16.12/net/ipv4/route.c bar/net/ipv4/route.c
--- linux-2.6.16.12/net/ipv4/route.c	2006-05-01 12:14:26.000000000 -0700
+++ bar/net/ipv4/route.c	2006-05-01 17:23:42.774468404 -0700
@@ -2401,8 +2401,19 @@
 
 		/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */
 		dev_out = ip_dev_find(oldflp->fl4_src);
+#ifdef CONFIG_IP_NF_NONLOCAL
+        /* If address is not local, test for nonlocal flag;
+         * if address is local --- clear the flag.
+         */
+        if (dev_out == NULL) {
+            if (!(oldflp->fl4_tos & RTO_TPROXY) || inet_addr_type(oldflp->fl4_src) != RTN_UNICAST)
+                goto out;
+            flags |= RTCF_TPROXY;
+        }
+#else
 		if (dev_out == NULL)
 			goto out;
+#endif
 
 		/* I removed check for oif == dev_out->oif here.
 		   It was wrong for two reasons:
@@ -2413,6 +2424,7 @@
 		 */
 
 		if (oldflp->oif == 0
+                   && dev_out
 		    && (MULTICAST(oldflp->fl4_dst) || oldflp->fl4_dst == 0xFFFFFFFF)) {
 			/* Special hack: user can direct multicasts
 			   and limited broadcast via necessary interface
diff -rNu linux-2.6.16.12/net/ipv4/tcp_ipv4.c bar/net/ipv4/tcp_ipv4.c
--- linux-2.6.16.12/net/ipv4/tcp_ipv4.c	2006-05-01 12:14:26.000000000 -0700
+++ bar/net/ipv4/tcp_ipv4.c	2006-05-01 17:23:42.775468334 -0700
@@ -1157,6 +1157,83 @@
 	goto discard_it;
 }
 
+struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb)
+{
+    struct sock *sk = NULL;
+    int ihl;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb,IP_DEFRAG_NONLOCAL);
+        if (!skb)
+            return NULL;
+    }
+
+    ihl = skb->nh.iph->ihl*4;
+
+    if (!pskb_may_pull(skb, ihl+8))
+        goto out;
+
+    if (skb->nh.iph->protocol == IPPROTO_TCP) {           
+        struct tcphdr *th = (struct tcphdr*)(skb->nh.raw + ihl);
+    
+        sk = __inet_lookup(&tcp_hashinfo, skb->nh.iph->saddr, th->source,
+                             skb->nh.iph->daddr, ntohs(th->dest),
+                             skb->dev->ifindex);
+    }
+    if (skb->nh.iph->protocol == IPPROTO_ICMP) {
+#define ICMP_HDR_SIZE 8 /* 4 plus 4 unused */
+        /*size of icmp payload */
+	__u32 len = ntohs(skb->nh.iph->tot_len) - ihl - ICMP_HDR_SIZE; 
+        struct icmphdr *icmph = (struct icmphdr*)(skb->nh.raw + ihl);
+
+        if ((icmph->type == 3 && icmph->code == 4 ) || /* fragmentation needed */
+            (icmph->type == 4 && icmph->code == 0 ) || /* source quench */
+            (icmph->type == 12                    ))   /* parameter problem */
+        {
+        
+            if (len >= sizeof(struct iphdr)) {
+                struct iphdr* innerh = (struct iphdr*)(skb->nh.raw + ihl + ICMP_HDR_SIZE);
+                int innerhl = innerh->ihl*4;
+
+                /* is udp/tcp and has source/dest ports */
+		/* fix for bug 920 -- the router giving us the ICMP message
+		 * may only give us the first 8 bytes of the tcp header,
+		 * which since it has the source/dest ports, is all we need. */
+                if ((innerh->protocol == IPPROTO_TCP) && len >= (innerhl + 8)) {
+
+	                    struct tcphdr *th = (struct tcphdr*)(skb->nh.raw + ihl + ICMP_HDR_SIZE + innerhl);
+			    sk = __inet_lookup(&tcp_hashinfo, innerh->daddr, th->dest,
+                                         innerh->saddr, ntohs(th->source),
+                                         skb->dev->ifindex);
+
+                }
+            }
+        }
+    }
+
+    if (sk && sk->sk_reuse == 2) { /* exist and nonlocal bound */
+        struct iphdr  *iph;
+        iph = skb->nh.iph;
+
+        if (skb->dst == NULL) {
+            if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, skb->dev)) {
+                printk("ip_route_input failed\n");
+                goto out; 
+            }
+        }
+
+        skb->pkt_type = PACKET_HOST;
+        sock_put(sk);
+        ip_local_deliver(skb);
+        return NULL;
+    }
+    else if (sk) /*exist and is not nonlocally bound */
+        sock_put(sk);
+
+ out:
+    return skb;
+}
+
 /* VJ's idea. Save last timestamp seen from this destination
  * and hold it at least for normal timewait interval to use for duplicate
  * segment detection in subsequent connections, before they enter synchronized
