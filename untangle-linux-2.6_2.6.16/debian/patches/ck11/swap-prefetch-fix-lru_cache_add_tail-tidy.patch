From akpm@osdl.org Thu May 18 17:57:10 2006
Return-Path: <akpm@osdl.org>
X-Original-To: kernel@kolivas.org
Delivered-To: kernel@kolivas.org
Received: from bhhdoa.org.au (bhhdoa.org.au [65.98.99.88])
	by mail.kolivas.org (Postfix) with ESMTP id 9D79F9E201
	for <kernel@kolivas.org>; Thu, 18 May 2006 17:57:14 +1000 (EST)
Received: from smtp.osdl.org (smtp.osdl.org [65.172.181.4])
	by bhhdoa.org.au (Postfix) with ESMTP id 50395517F9
	for <kernel@kolivas.org>; Thu, 18 May 2006 15:53:30 +1000 (EST)
Received: from shell0.pdx.osdl.net (fw.osdl.org [65.172.181.6])
	by smtp.osdl.org (8.12.8/8.12.8) with ESMTP id k4I7v9tH000989
	(version=TLSv1/SSLv3 cipher=EDH-RSA-DES-CBC3-SHA bits=168 verify=NO);
	Thu, 18 May 2006 00:57:10 -0700
Received: from localhost.localdomain (shell0.pdx.osdl.net [10.9.0.31])
	by shell0.pdx.osdl.net (8.13.1/8.11.6) with ESMTP id k4I7v9TO012558;
	Thu, 18 May 2006 00:57:09 -0700
Message-Id: <200605180757.k4I7v9TO012558@shell0.pdx.osdl.net>
Subject: + swap-prefetch-fix-lru_cache_add_tail-tidy.patch added to -mm tree
To: akpm@osdl.org,
 a.p.zijlstra@chello.nl,
 kernel@kolivas.org,
 mm-commits@vger.kernel.org
From: akpm@osdl.org
Date: Thu, 18 May 2006 00:57:10 -0700
X-Spam-Status: No, hits=1.088 required=5 tests=NO_REAL_NAME
X-Spam-Level: *
X-Spam-Checker-Version: SpamAssassin 2.63-osdl_revision__1.74__
X-MIMEDefang-Filter: osdl$Revision: 1.134 $
X-Scanned-By: MIMEDefang 2.36
X-DSPAM-Result: Whitelisted
X-DSPAM-Confidence: 0.9997
X-DSPAM-Probability: 0.0000
X-DSPAM-Signature: 446c28e296891759557146
X-DSPAM-Factors: 27,
	var+lru, 0.00010,
	dirty+pages, 0.00010,
	dirty+pages, 0.00010,
	macros, 0.00010,
	macros, 0.00010,
	tail+struct, 0.00010,
	tail+struct, 0.00010,
	put+cpu, 0.00010,
	struct+pagevec, 0.00010,
	struct+pagevec, 0.00010,
	lru+lock, 0.00010,
	lru+lock, 0.00010,
	irq+zone, 0.00010,
	irq+zone, 0.00010,
	devel+mm, 0.00010,
	pagevec, 0.00010,
	pagevec, 0.00010,
	only+patch, 0.00010,
	ON+PageLRU, 0.00010,
	ON+PageLRU, 0.00010,
	add+active, 0.00010,
	add+active, 0.00010,
	pvecs, 0.00010,
	patch+git, 0.00010,
	patch+git, 0.00010,
	zone+lru, 0.00010,
	zone+lru, 0.00010
X-UID: 19441
X-Length: 10183
Status: R
X-Status: NC
X-KMail-EncryptionState:  
X-KMail-SignatureState:  
X-KMail-MDN-Sent:  


The patch titled

     swap-prefetch-fix-lru_cache_add_tail-tidy

has been added to the -mm tree.  Its filename is

     swap-prefetch-fix-lru_cache_add_tail-tidy.patch

See http://www.zip.com.au/~akpm/linux/patches/stuff/added-to-mm.txt to find
out what to do about this


From: Andrew Morton <akpm@osdl.org>

- Avoid the forward decl

- Too big for inlining.

Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Acked-by: Con Kolivas <kernel@kolivas.org>
Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 mm/swap.c |   50 ++++++++++++++++++++++++--------------------------
 1 files changed, 24 insertions(+), 26 deletions(-)

Index: linux-2.6.16-ck11/mm/swap.c
===================================================================
--- linux-2.6.16-ck11.orig/mm/swap.c	2006-05-21 12:24:27.000000000 +1000
+++ linux-2.6.16-ck11/mm/swap.c	2006-05-21 12:24:35.000000000 +1000
@@ -163,7 +163,30 @@ void fastcall lru_cache_add_active(struc
 	put_cpu_var(lru_add_active_pvecs);
 }
 
-static inline void __pagevec_lru_add_tail(struct pagevec *pvec);
+static void __pagevec_lru_add_tail(struct pagevec *pvec)
+{
+	int i;
+	struct zone *zone = NULL;
+
+	for (i = 0; i < pagevec_count(pvec); i++) {
+		struct page *page = pvec->pages[i];
+		struct zone *pagezone = page_zone(page);
+
+		if (pagezone != zone) {
+			if (zone)
+				spin_unlock_irq(&zone->lru_lock);
+			zone = pagezone;
+			spin_lock_irq(&zone->lru_lock);
+		}
+		BUG_ON(PageLRU(page));
+		SetPageLRU(page);
+		add_page_to_inactive_list_tail(zone, page);
+	}
+	if (zone)
+		spin_unlock_irq(&zone->lru_lock);
+	release_pages(pvec->pages, pvec->nr, pvec->cold);
+	pagevec_reinit(pvec);
+}
 
 static void __lru_add_drain(int cpu)
 {
@@ -391,31 +414,6 @@ void __pagevec_lru_add_active(struct pag
 	pagevec_reinit(pvec);
 }
 
-static inline void __pagevec_lru_add_tail(struct pagevec *pvec)
-{
-	int i;
-	struct zone *zone = NULL;
-
-	for (i = 0; i < pagevec_count(pvec); i++) {
-		struct page *page = pvec->pages[i];
-		struct zone *pagezone = page_zone(page);
-
-		if (pagezone != zone) {
-			if (zone)
-				spin_unlock_irq(&zone->lru_lock);
-			zone = pagezone;
-			spin_lock_irq(&zone->lru_lock);
-		}
-		BUG_ON(PageLRU(page));
-		SetPageLRU(page);
-		add_page_to_inactive_list_tail(zone, page);
-	}
-	if (zone)
-		spin_unlock_irq(&zone->lru_lock);
-	release_pages(pvec->pages, pvec->nr, pvec->cold);
-	pagevec_reinit(pvec);
-}
-
 /*
  * Function used uniquely to put pages back to the lru at the end of the
  * inactive list to preserve the lru order. Currently only used by swap
