diff -urN iptables-1.2.9/extensions/Makefile iptables-1.2.9-netcap/extensions/Makefile
--- iptables-1.2.9/extensions/Makefile	2003-10-16 00:34:36.000000000 -0700
+++ iptables-1.2.9-netcap/extensions/Makefile	2004-09-16 19:09:33.000000000 -0700
@@ -5,7 +5,7 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah connlimit connmark conntrack dscp ecn esp helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
+PF_EXT_SLIB:=ah bitmark connlimit connmark conntrack dscp ecn esp helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT DIVERT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
 PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner standard tcp udp HL LOG MARK TRACE
 
 # Optionals
diff -urN iptables-1.2.9/extensions/ipt_bitmark.c iptables-1.2.9-netcap/extensions/ipt_bitmark.c
--- iptables-1.2.9/extensions/ipt_bitmark.c	1969-12-31 16:00:00.000000000 -0800
+++ iptables-1.2.9-netcap/extensions/ipt_bitmark.c	2004-09-16 19:09:24.000000000 -0700
@@ -0,0 +1,98 @@
+/* IP tables module for bit matching the value of the nfmark 
+ *
+ * (C) 2004 by Jim Mar <jmar@metavize.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+
+#include <linux/netfilter_ipv4/ipt_bitmark.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+MODULE_AUTHOR("Jim Mar <jmar@bitmark.com>");
+MODULE_DESCRIPTION("IP tables nfmark bit matching module");
+MODULE_LICENSE("GPL");
+
+static int match(const struct sk_buff *skb, const struct net_device *in,
+		 const struct net_device *out, const void *matchinfo,
+		 int offset, int *hotdrop)
+{
+	const struct ipt_bitmark_info *info = matchinfo;
+	unsigned long x;
+
+	if (info->flags & 0x00000001) {
+		x = skb->nfmark & info->exactmsk;
+		if (info->invertxct == 0) {
+			if (x != info->exactval) {
+				return 0;
+			}
+		} else if (info->invertxct == 1) {
+			if (x == info->exactval) {
+				return 0;
+			}
+		}
+	}
+
+	if (info->flags & 0x00000002) {
+		x = skb->nfmark & info->anyone;
+		if (info->invertone == 0) {
+			if (x == 0) {
+				return 0;
+			}
+		} else if (info->invertone == 1) {
+			if (x != 0) {
+				return 0;
+			}
+		}
+	}
+
+	if (info->flags & 0x00000004) {
+		x = skb->nfmark & info->anyzed;
+		if (info->invertzed == 0) {
+			if (x == info->anyzed) {
+				return 0;
+			}
+		} else if (info->invertzed == 1) {
+			if (x != info->anyzed) {
+				return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+static int checkentry(const char *tablename, const struct ipt_ip *ip,
+		      void *matchinfo, unsigned int matchsize,
+		      unsigned int hook_mask)
+{
+	if (matchsize != IPT_ALIGN(sizeof(struct ipt_bitmark_info)))
+		return 0;
+
+	return 1;
+}
+
+static struct ipt_match bitmark_match = {
+	.name		= "bitmark",
+	.match		= &match,
+	.checkentry	= &checkentry,
+	.me		= THIS_MODULE,
+};
+
+static int __init init(void)
+{
+	return ipt_register_match(&bitmark_match);
+}
+
+static void __exit fini(void)
+{
+	ipt_unregister_match(&bitmark_match);
+
+}
+
+module_init(init);
+module_exit(fini);
diff -urN iptables-1.2.9/extensions/libipt_DIVERT.c iptables-1.2.9-netcap/extensions/libipt_DIVERT.c
--- iptables-1.2.9/extensions/libipt_DIVERT.c	1969-12-31 16:00:00.000000000 -0800
+++ iptables-1.2.9-netcap/extensions/libipt_DIVERT.c	2004-09-16 19:08:03.000000000 -0700
@@ -0,0 +1,103 @@
+/* Shared library add-on to iptables to add TPROXY target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_DIVERT.h>
+
+struct tosinfo {
+    struct ipt_entry_target t;
+    struct ipt_divert_target_info divert;
+};
+
+static void help(void)
+{
+    printf("DIVERT target v%s options:\n"
+           "  --to-port port                   DIVERT packets to port\n",
+           IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+    { "to-port", 1, 0, '1' },
+    { 0 }
+};
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache)
+{}
+
+static void parse_divert(const unsigned char *s, struct ipt_divert_target_info *info)
+{
+    int divert_port;
+    string_to_number(s, 0, 65535, &divert_port);
+    info->to_port = htons(divert_port);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+                 const struct ipt_entry *entry,
+                 struct ipt_entry_target **target)
+{
+    struct ipt_divert_target_info *divertinfo
+        = (struct ipt_divert_target_info *)(*target)->data;
+
+    switch (c) {
+    case '1':
+        if (*flags)
+            exit_error(PARAMETER_PROBLEM,"DIVERT target: Can't specify --to-port twice");
+        parse_divert(optarg, divertinfo);
+        *flags = 1;
+        break;
+
+    default:
+        return 0;
+    }
+
+    return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+    if (!flags)
+        exit_error(PARAMETER_PROBLEM,
+                   "DIVERT target: Parameter --to-port is required");
+}
+
+static void print(const struct ipt_ip *ip,
+                  const struct ipt_entry_target *target,
+                  int numeric)
+{
+    const struct ipt_divert_target_info *divertinfo =
+        (const struct ipt_divert_target_info *)target->data;
+    printf("DIVERT redirect %d", ntohs(divertinfo->to_port));
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+    const struct ipt_divert_target_info *divertinfo =
+        (const struct ipt_divert_target_info *)target->data;
+
+    printf("--to-port %d ", ntohs(divertinfo->to_port));
+}
+
+static 
+struct iptables_target divert 
+= { NULL,
+    "DIVERT",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_divert_target_info)),
+    IPT_ALIGN(sizeof(struct ipt_divert_target_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+    register_target(&divert);
+}
diff -urN iptables-1.2.9/extensions/libipt_bitmark.c iptables-1.2.9-netcap/extensions/libipt_bitmark.c
--- iptables-1.2.9/extensions/libipt_bitmark.c	1969-12-31 16:00:00.000000000 -0800
+++ iptables-1.2.9-netcap/extensions/libipt_bitmark.c	2004-09-16 19:16:38.000000000 -0700
@@ -0,0 +1,173 @@
+/* Shared library add-on to iptables to add nfmark bit matching support 
+ * (C) 2004 by Jim Mar <jmar@metavize.com>
+ *
+ * $Id
+ *
+ * This program is released under the terms of GNU GPL */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_bitmark.h>
+
+static void help(void) 
+{
+	printf(
+"bitmark match v%s options:\n"
+"[!] --bitexact  value/mask	Match nfmark value with required mask\n"
+"[!] --anyone mask		Match any one under mask\n"
+"[!] --anyzed mask		Match any zero under mask\n"
+, IPTABLES_VERSION);
+}
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* caching not yet implemented */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+		const struct ipt_entry *entry, unsigned int *nfcache,
+		struct ipt_entry_match **match)
+{
+	struct ipt_bitmark_info *info = (struct ipt_bitmark_info *) (*match)->data;
+	unsigned long value;
+	char *end;
+
+	check_inverse(optarg, &invert, &optind, 0);
+	value = strtoul(optarg, &end, 0);
+
+	if (!optarg)
+		exit_error(PARAMETER_PROBLEM,
+				"bitmark: You must specify a value");
+	switch (c) {
+		case '1':
+			if (*flags & 0x00000001)
+				exit_error(PARAMETER_PROBLEM,
+					"bitmark: Can't specify option none or once");
+			if (invert)
+				info->invertxct = 1;
+			else
+				info->invertxct = 0;
+
+			info->exactval = value;
+			if (*end != '/')
+				exit_error(PARAMETER_PROBLEM,
+					"bitmark: must specify a mask");
+			info->exactmsk = strtoul(end+1, &end, 0);
+			*flags |= 0x00000001;
+			info->flags = *flags;
+			break;
+		case '2':
+			if (*flags & 0x00000002)
+				exit_error(PARAMETER_PROBLEM,
+					"bitmark: Can't specify option none or once");
+			if (invert)
+				info->invertone = 1;
+			else
+				info->invertone = 0;
+
+			info->anyone = value;
+			*flags |= 0x00000002;
+			info->flags = *flags;
+			break;
+		case '3':
+			if (*flags & 0x00000004)
+				exit_error(PARAMETER_PROBLEM,
+					"bitmark: Can't specify option none or once");
+			if (invert)
+				info->invertzed = 1;
+			else
+				info->invertzed = 0;
+
+			info->anyzed = value;
+			*flags |= 0x00000004;
+			info->flags = *flags;
+			break;
+		default:
+			return 0;
+
+	}
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!flags) 
+		exit_error(PARAMETER_PROBLEM,
+			"bitmark match: You must specify one of "
+			"`--bitexact <value>/<mask>;"
+			"`--anyone <value>', `-anyzed <value>'");
+}
+
+static void print(const struct ipt_ip *ip, 
+		const struct ipt_entry_match *match,
+		int numeric)
+{
+	const struct ipt_bitmark_info *info = 
+		(struct ipt_bitmark_info *) match->data;
+
+	printf("bitmark match ");
+	if (info->flags & 0x00000001) {
+		if (info->invertone)
+			printf("! ");
+		printf("bitexact 0x%08lx/0x%08lx ",
+			info->exactval, info->exactmsk);
+	}
+	if (info->flags & 0x00000002) {
+		if (info->invertone)
+			printf("! ");
+		printf("anyone 0x%08lx ", info->anyone);
+	}
+	if (info->flags & 0x00000004) {
+		if (info->invertzed)
+			printf("! ");
+		printf("anyzed 0x%08lx ", info->anyzed);
+	}
+}
+
+static void save(const struct ipt_ip *ip, 
+		const struct ipt_entry_match *match)
+{
+	const struct ipt_bitmark_info *info =
+		(struct ipt_bitmark_info *) match->data;
+	if (info->invertone)
+		printf("! ");
+	printf("--anyone 0x%08lx ", info->anyone);
+	if (info->invertzed)
+		printf("! ");
+	printf("--anyzed 0x%08lx ", info->anyzed);
+}
+
+static struct option opts[] = {
+	{ "bitexact",  1, 0, '1'},
+	{ "anyone", 1, 0, '2'},
+	{ "anyzed", 1, 0, '3'},
+	{ 0 }
+};
+
+static
+struct iptables_match bitmark = {
+	NULL,
+	"bitmark",
+	IPTABLES_VERSION,
+	IPT_ALIGN(sizeof(struct ipt_bitmark_info)),
+	IPT_ALIGN(sizeof(struct ipt_bitmark_info)),
+	&help,
+	&init,
+	&parse,
+	&final_check,
+	&print,
+	&save,
+	opts
+};
+
+
+void _init(void) 
+{
+	register_match(&bitmark);
+}
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_DIVERT.h iptables-1.2.9-netcap/include/linux/netfilter_ipv4/ipt_DIVERT.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_DIVERT.h	1969-12-31 16:00:00.000000000 -0800
+++ iptables-1.2.9-netcap/include/linux/netfilter_ipv4/ipt_DIVERT.h	2004-09-16 19:08:38.000000000 -0700
@@ -0,0 +1,9 @@
+/* $Id: netcap.iptables-1.2.9.091604.patch,v 1.1.1.1 2005/01/11 22:59:32 dmorris Exp $ */
+#ifndef _IPT_DIVERT_H_target
+#define _IPT_DIVERT_H_target
+
+struct ipt_divert_target_info {
+	unsigned short to_port;
+};
+
+#endif
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_bitmark.h iptables-1.2.9-netcap/include/linux/netfilter_ipv4/ipt_bitmark.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_bitmark.h	1969-12-31 16:00:00.000000000 -0800
+++ iptables-1.2.9-netcap/include/linux/netfilter_ipv4/ipt_bitmark.h	2004-09-16 19:08:44.000000000 -0700
@@ -0,0 +1,18 @@
+/* IP tables module for matching the value of the TTL
+ * (C) 2004 by Jim Mar <jmar@metavize.com> */
+
+#ifndef _IPT_BITMARK_H
+#define _IPT_BITMARK_H
+
+struct ipt_bitmark_info {
+	int		invertxct;
+	int		invertone;
+	int		invertzed;
+	unsigned long	exactval;
+	unsigned long	exactmsk;
+	unsigned long	anyone;
+	unsigned long	anyzed;
+	unsigned long	flags;
+};
+
+#endif
