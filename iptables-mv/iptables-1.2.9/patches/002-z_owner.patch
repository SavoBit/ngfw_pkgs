--- debian.old/build/iptables-1.2.9/iptables.c	2003-03-31 07:11:55.000000000 -0500
+++ debian/build/iptables-1.2.9/iptables.c	2003-06-21 07:48:02.000000000 -0400
@@ -39,6 +39,8 @@
 #include <iptables.h>
 #include <fcntl.h>
 #include <sys/wait.h>
+#include <sys/utsname.h>
+#include <linux/version.h>
 
 #ifndef TRUE
 #define TRUE 1
@@ -55,6 +56,10 @@
 #define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
 #endif
 
+#define PRE_2_4_20 "+pre-2.4.20"
+#define POST_2_4_20 "+post-2.4.20"
+#define PRE_POST_LENGTH strlen(POST_2_4_20)
+
 #define FMT_NUMERIC	0x0001
 #define FMT_NOCOUNTS	0x0002
 #define FMT_KILOMEGAGIGA 0x0004
@@ -658,6 +663,20 @@
 	}
 }
 
+int
+is_pre_2_4_20(void)
+{
+	struct utsname buf;
+	int major, minor, revision;
+	if (uname(&buf) != 0) {
+		perror("uname failed - assuming pre 2.4.20");
+	}
+	if (sscanf(buf.release, "%d.%d.%d", &major, &minor, &revision) < 3) {
+		perror("sscanf failed - assuming pre 2.4.20");
+	}
+	return KERNEL_VERSION(major,minor,revision) < KERNEL_VERSION(2,4,20);
+}
+
 struct iptables_match *
 find_match(const char *name, enum ipt_tryload tryload)
 {
@@ -671,8 +690,16 @@
 #ifndef NO_SHARED_LIBS
 	if (!ptr && tryload != DONT_LOAD) {
 		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
-			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+			 + strlen(name) + PRE_POST_LENGTH];
+		if (strncmp(name, "owner", 6) == 0) {
+		    if (is_pre_2_4_20()) {
+		        sprintf(path, IPT_LIB_DIR "/libipt_%s.so" PRE_2_4_20, name);
+		    } else {
+		        sprintf(path, IPT_LIB_DIR "/libipt_%s.so" POST_2_4_20, name);
+		    }
+		} else {
+		        sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		}
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified target as match. */

--- debian.old/build/iptables-1.2.9/ip6tables.c	2003-12-26 01:43:08.000000000 -0500
+++ debian/build/iptables-1.2.9/ip6tables.c	2003-12-26 01:46:13.000000000 -0500
@@ -42,6 +42,8 @@
 #include <sys/wait.h>
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <sys/utsname.h>
+#include <linux/version.h>
 
 #ifndef TRUE
 #define TRUE 1
@@ -58,6 +60,10 @@
 #define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
 #endif
 
+#define PRE_2_4_20 "+pre-2.4.20"
+#define POST_2_4_20 "+post-2.4.20"
+#define PRE_POST_LENGTH strlen(POST_2_4_20)
+
 #define FMT_NUMERIC	0x0001
 #define FMT_NOCOUNTS	0x0002
 #define FMT_KILOMEGAGIGA 0x0004
@@ -702,6 +708,19 @@
 		}
 	}
 }
+int
+is_pre_2_4_20(void)
+{
+	struct utsname buf;
+	int major, minor, revision;
+	if (uname(&buf) != 0) {
+		perror("uname failed - assuming pre 2.4.20");
+	}
+	if (sscanf(buf.release, "%d.%d.%d", &major, &minor, &revision) < 3) {
+		perror("sscanf failed - assuming pre 2.4.20");
+	}
+	return KERNEL_VERSION(major,minor,revision) < KERNEL_VERSION(2,4,20);
+}
 
 struct ip6tables_match *
 find_match(const char *name, enum ip6t_tryload tryload)
@@ -949,8 +968,16 @@
 #ifndef NO_SHARED_LIBS
 	if (!ptr && tryload != DONT_LOAD) {
 		char path[sizeof(IP6T_LIB_DIR) + sizeof("/libip6t_.so")
-			 + strlen(name)];
-		sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so", name);
+			 + strlen(name) + PRE_POST_LENGTH];
+		if (strncmp(name, "owner", 6) == 0) {
+		    if (is_pre_2_4_20()) {
+		        sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so" PRE_2_4_20, name);
+		    } else {
+		        sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so" POST_2_4_20, name);
+		    }
+		} else {
+		        sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so", name);
+		}
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified match as a target. */
