#! /bin/bash

# FIXME should only add routse for active WANs

# script
SCRIPT_SET_LINK_MEDIA="/usr/share/untangle-netd/bin/set-link-media.sh"
SCRIPT_ADD_UPLINK="/usr/share/untangle-netd/bin/add-uplink.sh"

# This is the table name prefix of Untangle WAN tables
TABLE_PREFIX="uplink."

## All of the untangle rules MUST starting in this priority prefix.  
## This makes it easy to flush all of the untangle routing rules.
UNTANGLE_PRIORITY_BASE="36"

## Change this string you want to guarantee that the route tables are recreated.
IP_ROUTE_TABLE_MARKER="version1"

## The file the contains the names of the routing tables
IP_RT_TABLES="/etc/iproute2/rt_tables"
IP_RT_TABLE_BASE=0

## Maximum number of interfaces
MAX_INTERFACES=250

## Functions

debug()
{
    /bin/echo -e "[NETD DEBUG: `date`] ${*}"
}

debug_ip()
{
    debug ip $*
    ip $*
}

## Return the expected/desired state of the bridge interfaces
## returns an md5sum string summarizing the expected configuration of the bridges
bridge_expected()
{
    awk '
      /^iface.*inet/ { interface = $2  }
      /bridge_ports/ { print interface "[]"
                              gsub( "^[ \t]*bridge_ports[ \t]*", "")
                              split( $0, intf_array )
                              for ( i in intf_array ) print interface "[" intf_array[i] "]" }' /etc/network/interfaces | sort | md5sum | awk '{ print $1}'
}

## Return the current state of the bridge interfaces
## returns an md5sum string summarizing the current configuration of the bridges
bridge_current()
{
    find /sys/class/net/*/brif* 2>/dev/null | \
        sed -e 's|/sys/class/net/\([^/]*\)/brif/\?\(.*\)|\1[\2]|' | \
        sort | md5sum | awk '{ print $1}'
}

bridge_configured()
{
    local l_expected=`bridge_expected`
    local l_current=`bridge_current`
    
    #$DEBUG "EXPECTED(${l_expected}) CURRENT(${l_current})"
    if [ "${l_expected}" == "${l_current}" ] ; then
        $DEBUG "NETD bridge_configured() = true"
        return 0
    else
        $DEBUG "NETD bridge_configured() = false"
        return 1
    fi
}

## Return a list of all of the bridges
bridge_list()
{
    find /sys/class/net/*/bridge -name 'bridge_id' 2>/dev/null | sed -e 's|/sys/class/net/\([^/]*\)/.*|\1|'
}

## Return a list of interfaces that are in bridge. 
bridge_port_list()
{
    local l_bridge=$1
    
    test -n "${l_bridge}" && {
        find /sys/class/net/${l_bridge}/brif/ -maxdepth 1 -mindepth 1 -exec basename {} \; 2>/dev/null
    }
}

## Deconfigure all of the active bridges
bridge_delete_all()
{
    local l_bridge
    local l_port
    for l_bridge in `bridge_list` ; do
        $DEBUG "Deleting all of the interfaces in the bridge '${l_bridge}'."
        for l_port in `bridge_port_list ${l_bridge}` ; do
            $DEBUG "Deleting the interface '${l_port}' from the bridge '${l_bridge}'."
            brctl delif ${l_bridge} ${l_port}
            ifconfig ${l_port} 0.0.0.0
            ifconfig ${l_port} down
        done
        ifconfig ${l_bridge} down
        brctl delbr ${l_bridge}
    done
}

set_ethernet_media()
{
    local t_nic
    local t_media

    test -x "${SCRIPT_SET_LINK_MEDIA}" || { 
        echo "[WARN: `date`] '${SCRIPT_SET_LINK_MEDIA}' doesn't exist" 
        return 0
    }
 
    echo "FIXME set LINK MEDIA XXX"
    echo "FIXME set LINK MEDIA XXX"
    echo "FIXME set LINK MEDIA XXX"
#    cat "${ETHERNET_MEDIA_CONF}" | awk '/^[a-z][^#]*$/ { print }' | while read t_nic t_media ; do 
#        $DEBUG "${t_nic}, ${t_media}"
#        ${SCRIPT_SET_LINK_MEDIA} ${t_nic} ${t_media}
#    done
}

## Delete all of the rules thare are on one of the uplink tables.
flush_uplink_tables()
{
    local t_route
    ip route show table all | grep  "${TABLE_PREFIX}" | while read t_route ; do
        ${IP} route delete ${t_route}
    done
}

## Remove all of the rules
flush_uplink_rules()
{
    local t_priority
    
    for t_priority in `ip rule show | awk "/^${UNTANGLE_PRIORITY_BASE}[0-9][0-9][0-9]:/ { sub( \":\", \"\", \\$1 ) ; print \\$1 }"` ; do
        ${IP} rule delete priority ${t_priority}
    done    
}

insert_uplink_tables()
{
    local t_temp
    local t_index

    # if untangle has written the uplink tables already just return
    grep -q "${IP_ROUTE_TABLE_MARKER}" ${IP_RT_TABLES} && return

    t_temp=`mktemp`
    
    echo "# ${IP_ROUTE_TABLE_MARKER} MultiWAN uplink tables" >> ${t_temp}

    for t_index in `seq 1 $MAX_INTERFACES`; do
        /bin/echo -e "$((${IP_RT_TABLE_BASE} + ${t_index}))\t${TABLE_PREFIX}${t_index}" >> ${t_temp}
    done
    
    sed -i -e '/uplink/d'  -e "/MultiWAN uplink tables/d" ${IP_RT_TABLES}
    cat ${t_temp} >> ${IP_RT_TABLES}
    
    rm -f ${t_temp}
}

flush_uplinks()
{
    flush_uplink_tables
    flush_uplink_rules
    ## Make sure that all of the tables exist.
    insert_uplink_tables
}

networking_pre_restart_hook()
{
    $DEBUG "networking_pre_restart_hook"

    $DEBUG "Stopping all dhcp daemons"
    ## If there are any processes, wait a little, then make sure they are gone.
    pkill -QUIT '(dhclient3|pump|dhclient)' && { sleep 1 ; pkill '(dhclient3|pump|dhclient)'; }
    
    $DEBUG "Cleaning up the interface state."
    
    ## REVIEW : Possibly add a label for dynamically configured 
    ## interfaces.
    ## REVIEW : Down all interfaces that are not supposed to be
    ## configured, eg ifconfig down <intf> for everything that is not
    ## used.
    $DEBUG "Flushing interface addresses."
    ip addr flush scope global 2>/dev/null
    
    $DEBUG "Flush all uplink routes."
    flush_uplinks
    
    $DEBUG "Configuring network media."
    set_ethernet_media
    
    $DEBUG "Stopping all active PPP Connections."
    poff -a
    
    bridge_configured || {
    # Determine which bridges need to be removed
        $DEBUG "Destroying all of the bridges."
        bridge_delete_all
    }
}

netd_address()
{
    $DEBUG "netd_address: IF_NETD_V4_ADDRESS = ${IF_NETD_V4_ADDRESS}"
    $DEBUG "netd_address: IF_NETD_V4_NETMASK = ${IF_NETD_V4_NETMASK}"
    $DEBUG "netd_address: IF_NETD_V4_GATEWAY = ${IF_NETD_V4_GATEWAY}"

    if [ -n "${IF_NETD_V4_ADDRESS}" ] && [ -n "${IF_NETD_V4_NETMASK}" ]; then
        $DEBUG ifconfig $IFACE ${IF_NETD_V4_ADDRESS} netmask ${IF_NETD_V4_NETMASK} up
        ifconfig $IFACE ${IF_NETD_V4_ADDRESS} netmask ${IF_NETD_V4_NETMASK} up
    fi
    
    if [ -n "${IF_NETD_V4_GATEWAY}" ]; then
        $DEBUG ip route replace default via ${IF_NETD_V4_GATEWAY}
        ip route replace default via ${IF_NETD_V4_GATEWAY}
    fi
    
    return 0
}

networking_post_restart_hook()
{
    $DEBUG "networking_post_restart_hook"

    # FIXME
    # restart run the necessary stuff 
    # This is what "update-address" used to be
    return 0
}

uplink_routes()
{
    local t_rt_table
    local t_priority

    [ -z "$IF_NETD_V4_GATEWAY" ] && {
        $DEBUG "skipping uplink for ${IFACE}"
        return 0
    }

    [ -z "$IF_NETD_V4_ADDRESS" ] && {
        $DEBUG "skipping uplink for ${IFACE}"
        return 0
    }

    [ -x "${SCRIPT_ADD_UPLINK}" ] || {
        $DEBUG "Missing the script '${SCRIPT_ADD_UPLINK}'."
        return 0        
    }

    [ -z "$IF_NETD_INTERFACE_INDEX" ] && {
        $DEBUG "Interface ${IFACE} is missing the interface index."
        return 0
    }
    
    t_rt_table="${TABLE_PREFIX}${IF_NETD_INTERFACE_INDEX}"
    ${SCRIPT_ADD_UPLINK} ${IFACE} ${IF_NETD_V4_GATEWAY} ${t_rt_table}
}

## Start of script

IP="ip"
DEBUG=/bin/true
IF_NETD_DEBUG="true"

test "${IF_NETD_DEBUG}" = "true" && {
    DEBUG="debug"
    IP="debug_ip"
}

$DEBUG "if-up.d start [$IFACE]"

if [ $IFACE == "networking_pre_restart_hook" ] ; then
    networking_pre_restart_hook
fi

$DEBUG "netd_address"
netd_address

if [ $IFACE == "networking_post_restart_hook" ] ; then
    networking_post_restart_hook
fi

uplink_routes

$DEBUG "if-up.d end   [$IFACE]"

## always exit 0
exit 0
